{"ast":null,"code":"'use strict';\n\nexports.assign = function (tokenizer) {\n  //NOTE: obtain Tokenizer proto this way to avoid module circular references\n  var tokenizerProto = Object.getPrototypeOf(tokenizer);\n  tokenizer.tokenStartLoc = -1; //NOTE: add location info builder method\n\n  tokenizer._attachLocationInfo = function (token) {\n    token.location = {\n      start: this.tokenStartLoc,\n      end: -1\n    };\n  }; //NOTE: patch token creation methods and attach location objects\n\n\n  tokenizer._createStartTagToken = function (tagNameFirstCh) {\n    tokenizerProto._createStartTagToken.call(this, tagNameFirstCh);\n\n    this._attachLocationInfo(this.currentToken);\n  };\n\n  tokenizer._createEndTagToken = function (tagNameFirstCh) {\n    tokenizerProto._createEndTagToken.call(this, tagNameFirstCh);\n\n    this._attachLocationInfo(this.currentToken);\n  };\n\n  tokenizer._createCommentToken = function () {\n    tokenizerProto._createCommentToken.call(this);\n\n    this._attachLocationInfo(this.currentToken);\n  };\n\n  tokenizer._createDoctypeToken = function (doctypeNameFirstCh) {\n    tokenizerProto._createDoctypeToken.call(this, doctypeNameFirstCh);\n\n    this._attachLocationInfo(this.currentToken);\n  };\n\n  tokenizer._createCharacterToken = function (type, ch) {\n    tokenizerProto._createCharacterToken.call(this, type, ch);\n\n    this._attachLocationInfo(this.currentCharacterToken);\n  }; //NOTE: patch token emission methods to determine end location\n\n\n  tokenizer._emitCurrentToken = function () {\n    //NOTE: if we have pending character token make it's end location equal to the\n    //current token's start location.\n    if (this.currentCharacterToken) this.currentCharacterToken.location.end = this.currentToken.location.start;\n    this.currentToken.location.end = this.preprocessor.pos + 1;\n\n    tokenizerProto._emitCurrentToken.call(this);\n  };\n\n  tokenizer._emitCurrentCharacterToken = function () {\n    //NOTE: if we have character token and it's location wasn't set in the _emitCurrentToken(),\n    //then set it's location at the current preprocessor position\n    if (this.currentCharacterToken && this.currentCharacterToken.location.end === -1) {\n      //NOTE: we don't need to increment preprocessor position, since character token\n      //emission is always forced by the start of the next character token here.\n      //So, we already have advanced position.\n      this.currentCharacterToken.location.end = this.preprocessor.pos;\n    }\n\n    tokenizerProto._emitCurrentCharacterToken.call(this);\n  }; //NOTE: patch initial states for each mode to obtain token start position\n\n\n  Object.keys(tokenizerProto.MODE).map(function (modeName) {\n    return tokenizerProto.MODE[modeName];\n  }).forEach(function (state) {\n    tokenizer[state] = function (cp) {\n      this.tokenStartLoc = this.preprocessor.pos;\n      tokenizerProto[state].call(this, cp);\n    };\n  });\n};","map":{"version":3,"sources":["F:/JavaScript/Projects/chemistryphile/node_modules/jsdom-no-contextify/node_modules/parse5/lib/tokenization/location_info_mixin.js"],"names":["exports","assign","tokenizer","tokenizerProto","Object","getPrototypeOf","tokenStartLoc","_attachLocationInfo","token","location","start","end","_createStartTagToken","tagNameFirstCh","call","currentToken","_createEndTagToken","_createCommentToken","_createDoctypeToken","doctypeNameFirstCh","_createCharacterToken","type","ch","currentCharacterToken","_emitCurrentToken","preprocessor","pos","_emitCurrentCharacterToken","keys","MODE","map","modeName","forEach","state","cp"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nexports.assign = function (tokenizer) {\r\n    //NOTE: obtain Tokenizer proto this way to avoid module circular references\r\n    var tokenizerProto = Object.getPrototypeOf(tokenizer);\r\n\r\n    tokenizer.tokenStartLoc = -1;\r\n\r\n    //NOTE: add location info builder method\r\n    tokenizer._attachLocationInfo = function (token) {\r\n        token.location = {\r\n            start: this.tokenStartLoc,\r\n            end: -1\r\n        };\r\n    };\r\n\r\n    //NOTE: patch token creation methods and attach location objects\r\n    tokenizer._createStartTagToken = function (tagNameFirstCh) {\r\n        tokenizerProto._createStartTagToken.call(this, tagNameFirstCh);\r\n        this._attachLocationInfo(this.currentToken);\r\n    };\r\n\r\n    tokenizer._createEndTagToken = function (tagNameFirstCh) {\r\n        tokenizerProto._createEndTagToken.call(this, tagNameFirstCh);\r\n        this._attachLocationInfo(this.currentToken);\r\n    };\r\n\r\n    tokenizer._createCommentToken = function () {\r\n        tokenizerProto._createCommentToken.call(this);\r\n        this._attachLocationInfo(this.currentToken);\r\n    };\r\n\r\n    tokenizer._createDoctypeToken = function (doctypeNameFirstCh) {\r\n        tokenizerProto._createDoctypeToken.call(this, doctypeNameFirstCh);\r\n        this._attachLocationInfo(this.currentToken);\r\n    };\r\n\r\n    tokenizer._createCharacterToken = function (type, ch) {\r\n        tokenizerProto._createCharacterToken.call(this, type, ch);\r\n        this._attachLocationInfo(this.currentCharacterToken);\r\n    };\r\n\r\n    //NOTE: patch token emission methods to determine end location\r\n    tokenizer._emitCurrentToken = function () {\r\n        //NOTE: if we have pending character token make it's end location equal to the\r\n        //current token's start location.\r\n        if (this.currentCharacterToken)\r\n            this.currentCharacterToken.location.end = this.currentToken.location.start;\r\n\r\n        this.currentToken.location.end = this.preprocessor.pos + 1;\r\n        tokenizerProto._emitCurrentToken.call(this);\r\n    };\r\n\r\n    tokenizer._emitCurrentCharacterToken = function () {\r\n        //NOTE: if we have character token and it's location wasn't set in the _emitCurrentToken(),\r\n        //then set it's location at the current preprocessor position\r\n        if (this.currentCharacterToken && this.currentCharacterToken.location.end === -1) {\r\n            //NOTE: we don't need to increment preprocessor position, since character token\r\n            //emission is always forced by the start of the next character token here.\r\n            //So, we already have advanced position.\r\n            this.currentCharacterToken.location.end = this.preprocessor.pos;\r\n        }\r\n\r\n        tokenizerProto._emitCurrentCharacterToken.call(this);\r\n    };\r\n\r\n    //NOTE: patch initial states for each mode to obtain token start position\r\n    Object.keys(tokenizerProto.MODE)\r\n\r\n        .map(function (modeName) {\r\n            return tokenizerProto.MODE[modeName];\r\n        })\r\n\r\n        .forEach(function (state) {\r\n            tokenizer[state] = function (cp) {\r\n                this.tokenStartLoc = this.preprocessor.pos;\r\n                tokenizerProto[state].call(this, cp);\r\n            };\r\n        });\r\n};\r\n"]},"metadata":{},"sourceType":"script"}