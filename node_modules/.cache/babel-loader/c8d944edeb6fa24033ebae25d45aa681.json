{"ast":null,"code":"'use strict';\n\nvar OpenElementStack = require('./open_element_stack'),\n    Tokenizer = require('../tokenization/tokenizer'),\n    HTML = require('../common/html'); //Aliases\n\n\nvar $ = HTML.TAG_NAMES;\n\nfunction setEndLocation(element, closingToken, treeAdapter) {\n  var loc = element.__location;\n  if (!loc) return;\n\n  if (!loc.startTag) {\n    loc.startTag = {\n      start: loc.start,\n      end: loc.end\n    };\n  }\n\n  if (closingToken.location) {\n    var tn = treeAdapter.getTagName(element),\n        // NOTE: For cases like <p> <p> </p> - First 'p' closes without a closing tag and\n    // for cases like <td> <p> </td> - 'p' closes without a closing tag\n    isClosingEndTag = closingToken.type === Tokenizer.END_TAG_TOKEN && tn === closingToken.tagName;\n\n    if (isClosingEndTag) {\n      loc.endTag = {\n        start: closingToken.location.start,\n        end: closingToken.location.end\n      };\n    }\n\n    loc.end = closingToken.location.end;\n  }\n} //NOTE: patch open elements stack, so we can assign end location for the elements\n\n\nfunction patchOpenElementsStack(stack, parser) {\n  var treeAdapter = parser.treeAdapter;\n\n  stack.pop = function () {\n    setEndLocation(this.current, parser.currentToken, treeAdapter);\n    OpenElementStack.prototype.pop.call(this);\n  };\n\n  stack.popAllUpToHtmlElement = function () {\n    for (var i = this.stackTop; i > 0; i--) setEndLocation(this.items[i], parser.currentToken, treeAdapter);\n\n    OpenElementStack.prototype.popAllUpToHtmlElement.call(this);\n  };\n\n  stack.remove = function (element) {\n    setEndLocation(element, parser.currentToken, treeAdapter);\n    OpenElementStack.prototype.remove.call(this, element);\n  };\n}\n\nexports.assign = function (parser) {\n  //NOTE: obtain Parser proto this way to avoid module circular references\n  var parserProto = Object.getPrototypeOf(parser),\n      treeAdapter = parser.treeAdapter; //NOTE: patch _reset method\n\n  parser._reset = function (html, document, fragmentContext) {\n    parserProto._reset.call(this, html, document, fragmentContext);\n\n    this.attachableElementLocation = null;\n    this.lastFosterParentingLocation = null;\n    this.currentToken = null;\n    patchOpenElementsStack(this.openElements, parser);\n  };\n\n  parser._processTokenInForeignContent = function (token) {\n    this.currentToken = token;\n\n    parserProto._processTokenInForeignContent.call(this, token);\n  };\n\n  parser._processToken = function (token) {\n    this.currentToken = token;\n\n    parserProto._processToken.call(this, token); //NOTE: <body> and <html> are never popped from the stack, so we need to updated\n    //their end location explicitly.\n\n\n    if (token.type === Tokenizer.END_TAG_TOKEN && (token.tagName === $.HTML || token.tagName === $.BODY && this.openElements.hasInScope($.BODY))) {\n      for (var i = this.openElements.stackTop; i >= 0; i--) {\n        var element = this.openElements.items[i];\n\n        if (this.treeAdapter.getTagName(element) === token.tagName) {\n          setEndLocation(element, token, treeAdapter);\n          break;\n        }\n      }\n    }\n  }; //Doctype\n\n\n  parser._setDocumentType = function (token) {\n    parserProto._setDocumentType.call(this, token);\n\n    var documentChildren = this.treeAdapter.getChildNodes(this.document),\n        cnLength = documentChildren.length;\n\n    for (var i = 0; i < cnLength; i++) {\n      var node = documentChildren[i];\n\n      if (this.treeAdapter.isDocumentTypeNode(node)) {\n        node.__location = token.location;\n        break;\n      }\n    }\n  }; //Elements\n\n\n  parser._attachElementToTree = function (element) {\n    //NOTE: _attachElementToTree is called from _appendElement, _insertElement and _insertTemplate methods.\n    //So we will use token location stored in this methods for the element.\n    element.__location = this.attachableElementLocation || null;\n    this.attachableElementLocation = null;\n\n    parserProto._attachElementToTree.call(this, element);\n  };\n\n  parser._appendElement = function (token, namespaceURI) {\n    this.attachableElementLocation = token.location;\n\n    parserProto._appendElement.call(this, token, namespaceURI);\n  };\n\n  parser._insertElement = function (token, namespaceURI) {\n    this.attachableElementLocation = token.location;\n\n    parserProto._insertElement.call(this, token, namespaceURI);\n  };\n\n  parser._insertTemplate = function (token) {\n    this.attachableElementLocation = token.location;\n\n    parserProto._insertTemplate.call(this, token);\n\n    var tmplContent = this.treeAdapter.getChildNodes(this.openElements.current)[0];\n    tmplContent.__location = null;\n  };\n\n  parser._insertFakeRootElement = function () {\n    parserProto._insertFakeRootElement.call(this);\n\n    this.openElements.current.__location = null;\n  }; //Comments\n\n\n  parser._appendCommentNode = function (token, parent) {\n    parserProto._appendCommentNode.call(this, token, parent);\n\n    var children = this.treeAdapter.getChildNodes(parent),\n        commentNode = children[children.length - 1];\n    commentNode.__location = token.location;\n  }; //Text\n\n\n  parser._findFosterParentingLocation = function () {\n    //NOTE: store last foster parenting location, so we will be able to find inserted text\n    //in case of foster parenting\n    this.lastFosterParentingLocation = parserProto._findFosterParentingLocation.call(this);\n    return this.lastFosterParentingLocation;\n  };\n\n  parser._insertCharacters = function (token) {\n    parserProto._insertCharacters.call(this, token);\n\n    var hasFosterParent = this._shouldFosterParentOnInsertion(),\n        parentingLocation = this.lastFosterParentingLocation,\n        parent = hasFosterParent && parentingLocation.parent || this.openElements.currentTmplContent || this.openElements.current,\n        siblings = this.treeAdapter.getChildNodes(parent),\n        textNodeIdx = hasFosterParent && parentingLocation.beforeElement ? siblings.indexOf(parentingLocation.beforeElement) - 1 : siblings.length - 1,\n        textNode = siblings[textNodeIdx]; //NOTE: if we have location assigned by another token, then just update end position\n\n\n    if (textNode.__location) textNode.__location.end = token.location.end;else textNode.__location = token.location;\n  };\n};","map":{"version":3,"sources":["F:/JavaScript/Projects/chemistryphile/node_modules/jsdom-no-contextify/node_modules/parse5/lib/tree_construction/location_info_mixin.js"],"names":["OpenElementStack","require","Tokenizer","HTML","$","TAG_NAMES","setEndLocation","element","closingToken","treeAdapter","loc","__location","startTag","start","end","location","tn","getTagName","isClosingEndTag","type","END_TAG_TOKEN","tagName","endTag","patchOpenElementsStack","stack","parser","pop","current","currentToken","prototype","call","popAllUpToHtmlElement","i","stackTop","items","remove","exports","assign","parserProto","Object","getPrototypeOf","_reset","html","document","fragmentContext","attachableElementLocation","lastFosterParentingLocation","openElements","_processTokenInForeignContent","token","_processToken","BODY","hasInScope","_setDocumentType","documentChildren","getChildNodes","cnLength","length","node","isDocumentTypeNode","_attachElementToTree","_appendElement","namespaceURI","_insertElement","_insertTemplate","tmplContent","_insertFakeRootElement","_appendCommentNode","parent","children","commentNode","_findFosterParentingLocation","_insertCharacters","hasFosterParent","_shouldFosterParentOnInsertion","parentingLocation","currentTmplContent","siblings","textNodeIdx","beforeElement","indexOf","textNode"],"mappings":"AAAA;;AAEA,IAAIA,gBAAgB,GAAGC,OAAO,CAAC,sBAAD,CAA9B;AAAA,IACIC,SAAS,GAAGD,OAAO,CAAC,2BAAD,CADvB;AAAA,IAEIE,IAAI,GAAGF,OAAO,CAAC,gBAAD,CAFlB,C,CAKA;;;AACA,IAAIG,CAAC,GAAGD,IAAI,CAACE,SAAb;;AAGA,SAASC,cAAT,CAAwBC,OAAxB,EAAiCC,YAAjC,EAA+CC,WAA/C,EAA4D;AACxD,MAAIC,GAAG,GAAGH,OAAO,CAACI,UAAlB;AAEA,MAAI,CAACD,GAAL,EACI;;AAEJ,MAAI,CAACA,GAAG,CAACE,QAAT,EAAmB;AACfF,IAAAA,GAAG,CAACE,QAAJ,GAAe;AACXC,MAAAA,KAAK,EAAEH,GAAG,CAACG,KADA;AAEXC,MAAAA,GAAG,EAAEJ,GAAG,CAACI;AAFE,KAAf;AAIH;;AAED,MAAIN,YAAY,CAACO,QAAjB,EAA2B;AACvB,QAAIC,EAAE,GAAGP,WAAW,CAACQ,UAAZ,CAAuBV,OAAvB,CAAT;AAAA,QACI;AACA;AACAW,IAAAA,eAAe,GAAGV,YAAY,CAACW,IAAb,KAAsBjB,SAAS,CAACkB,aAAhC,IACAJ,EAAE,KAAKR,YAAY,CAACa,OAJ1C;;AAMA,QAAIH,eAAJ,EAAqB;AACjBR,MAAAA,GAAG,CAACY,MAAJ,GAAa;AACTT,QAAAA,KAAK,EAAEL,YAAY,CAACO,QAAb,CAAsBF,KADpB;AAETC,QAAAA,GAAG,EAAEN,YAAY,CAACO,QAAb,CAAsBD;AAFlB,OAAb;AAIH;;AAEDJ,IAAAA,GAAG,CAACI,GAAJ,GAAUN,YAAY,CAACO,QAAb,CAAsBD,GAAhC;AACH;AACJ,C,CAED;;;AACA,SAASS,sBAAT,CAAgCC,KAAhC,EAAuCC,MAAvC,EAA+C;AAC3C,MAAIhB,WAAW,GAAGgB,MAAM,CAAChB,WAAzB;;AAEAe,EAAAA,KAAK,CAACE,GAAN,GAAY,YAAY;AACpBpB,IAAAA,cAAc,CAAC,KAAKqB,OAAN,EAAeF,MAAM,CAACG,YAAtB,EAAoCnB,WAApC,CAAd;AACAT,IAAAA,gBAAgB,CAAC6B,SAAjB,CAA2BH,GAA3B,CAA+BI,IAA/B,CAAoC,IAApC;AACH,GAHD;;AAKAN,EAAAA,KAAK,CAACO,qBAAN,GAA8B,YAAY;AACtC,SAAK,IAAIC,CAAC,GAAG,KAAKC,QAAlB,EAA4BD,CAAC,GAAG,CAAhC,EAAmCA,CAAC,EAApC,EACI1B,cAAc,CAAC,KAAK4B,KAAL,CAAWF,CAAX,CAAD,EAAgBP,MAAM,CAACG,YAAvB,EAAqCnB,WAArC,CAAd;;AAEJT,IAAAA,gBAAgB,CAAC6B,SAAjB,CAA2BE,qBAA3B,CAAiDD,IAAjD,CAAsD,IAAtD;AACH,GALD;;AAOAN,EAAAA,KAAK,CAACW,MAAN,GAAe,UAAU5B,OAAV,EAAmB;AAC9BD,IAAAA,cAAc,CAACC,OAAD,EAAUkB,MAAM,CAACG,YAAjB,EAA+BnB,WAA/B,CAAd;AACAT,IAAAA,gBAAgB,CAAC6B,SAAjB,CAA2BM,MAA3B,CAAkCL,IAAlC,CAAuC,IAAvC,EAA6CvB,OAA7C;AACH,GAHD;AAIH;;AAED6B,OAAO,CAACC,MAAR,GAAiB,UAAUZ,MAAV,EAAkB;AAC/B;AACA,MAAIa,WAAW,GAAGC,MAAM,CAACC,cAAP,CAAsBf,MAAtB,CAAlB;AAAA,MACIhB,WAAW,GAAGgB,MAAM,CAAChB,WADzB,CAF+B,CAM/B;;AACAgB,EAAAA,MAAM,CAACgB,MAAP,GAAgB,UAAUC,IAAV,EAAgBC,QAAhB,EAA0BC,eAA1B,EAA2C;AACvDN,IAAAA,WAAW,CAACG,MAAZ,CAAmBX,IAAnB,CAAwB,IAAxB,EAA8BY,IAA9B,EAAoCC,QAApC,EAA8CC,eAA9C;;AAEA,SAAKC,yBAAL,GAAiC,IAAjC;AACA,SAAKC,2BAAL,GAAmC,IAAnC;AACA,SAAKlB,YAAL,GAAoB,IAApB;AAEAL,IAAAA,sBAAsB,CAAC,KAAKwB,YAAN,EAAoBtB,MAApB,CAAtB;AACH,GARD;;AAUAA,EAAAA,MAAM,CAACuB,6BAAP,GAAuC,UAAUC,KAAV,EAAiB;AACpD,SAAKrB,YAAL,GAAoBqB,KAApB;;AACAX,IAAAA,WAAW,CAACU,6BAAZ,CAA0ClB,IAA1C,CAA+C,IAA/C,EAAqDmB,KAArD;AACH,GAHD;;AAKAxB,EAAAA,MAAM,CAACyB,aAAP,GAAuB,UAAUD,KAAV,EAAiB;AACpC,SAAKrB,YAAL,GAAoBqB,KAApB;;AACAX,IAAAA,WAAW,CAACY,aAAZ,CAA0BpB,IAA1B,CAA+B,IAA/B,EAAqCmB,KAArC,EAFoC,CAIpC;AACA;;;AACA,QAAIA,KAAK,CAAC9B,IAAN,KAAejB,SAAS,CAACkB,aAAzB,KACC6B,KAAK,CAAC5B,OAAN,KAAkBjB,CAAC,CAACD,IAApB,IACA8C,KAAK,CAAC5B,OAAN,KAAkBjB,CAAC,CAAC+C,IAApB,IAA4B,KAAKJ,YAAL,CAAkBK,UAAlB,CAA6BhD,CAAC,CAAC+C,IAA/B,CAF7B,CAAJ,EAEyE;AACrE,WAAK,IAAInB,CAAC,GAAG,KAAKe,YAAL,CAAkBd,QAA/B,EAAyCD,CAAC,IAAI,CAA9C,EAAiDA,CAAC,EAAlD,EAAsD;AAClD,YAAIzB,OAAO,GAAG,KAAKwC,YAAL,CAAkBb,KAAlB,CAAwBF,CAAxB,CAAd;;AAEA,YAAI,KAAKvB,WAAL,CAAiBQ,UAAjB,CAA4BV,OAA5B,MAAyC0C,KAAK,CAAC5B,OAAnD,EAA4D;AACxDf,UAAAA,cAAc,CAACC,OAAD,EAAU0C,KAAV,EAAiBxC,WAAjB,CAAd;AACA;AACH;AACJ;AACJ;AACJ,GAlBD,CAtB+B,CA0C/B;;;AACAgB,EAAAA,MAAM,CAAC4B,gBAAP,GAA0B,UAAUJ,KAAV,EAAiB;AACvCX,IAAAA,WAAW,CAACe,gBAAZ,CAA6BvB,IAA7B,CAAkC,IAAlC,EAAwCmB,KAAxC;;AAEA,QAAIK,gBAAgB,GAAG,KAAK7C,WAAL,CAAiB8C,aAAjB,CAA+B,KAAKZ,QAApC,CAAvB;AAAA,QACIa,QAAQ,GAAGF,gBAAgB,CAACG,MADhC;;AAGA,SAAK,IAAIzB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGwB,QAApB,EAA8BxB,CAAC,EAA/B,EAAmC;AAC/B,UAAI0B,IAAI,GAAGJ,gBAAgB,CAACtB,CAAD,CAA3B;;AAEA,UAAI,KAAKvB,WAAL,CAAiBkD,kBAAjB,CAAoCD,IAApC,CAAJ,EAA+C;AAC3CA,QAAAA,IAAI,CAAC/C,UAAL,GAAkBsC,KAAK,CAAClC,QAAxB;AACA;AACH;AACJ;AACJ,GAdD,CA3C+B,CA2D/B;;;AACAU,EAAAA,MAAM,CAACmC,oBAAP,GAA8B,UAAUrD,OAAV,EAAmB;AAC7C;AACA;AACAA,IAAAA,OAAO,CAACI,UAAR,GAAqB,KAAKkC,yBAAL,IAAkC,IAAvD;AACA,SAAKA,yBAAL,GAAiC,IAAjC;;AACAP,IAAAA,WAAW,CAACsB,oBAAZ,CAAiC9B,IAAjC,CAAsC,IAAtC,EAA4CvB,OAA5C;AACH,GAND;;AAQAkB,EAAAA,MAAM,CAACoC,cAAP,GAAwB,UAAUZ,KAAV,EAAiBa,YAAjB,EAA+B;AACnD,SAAKjB,yBAAL,GAAiCI,KAAK,CAAClC,QAAvC;;AACAuB,IAAAA,WAAW,CAACuB,cAAZ,CAA2B/B,IAA3B,CAAgC,IAAhC,EAAsCmB,KAAtC,EAA6Ca,YAA7C;AACH,GAHD;;AAKArC,EAAAA,MAAM,CAACsC,cAAP,GAAwB,UAAUd,KAAV,EAAiBa,YAAjB,EAA+B;AACnD,SAAKjB,yBAAL,GAAiCI,KAAK,CAAClC,QAAvC;;AACAuB,IAAAA,WAAW,CAACyB,cAAZ,CAA2BjC,IAA3B,CAAgC,IAAhC,EAAsCmB,KAAtC,EAA6Ca,YAA7C;AACH,GAHD;;AAKArC,EAAAA,MAAM,CAACuC,eAAP,GAAyB,UAAUf,KAAV,EAAiB;AACtC,SAAKJ,yBAAL,GAAiCI,KAAK,CAAClC,QAAvC;;AACAuB,IAAAA,WAAW,CAAC0B,eAAZ,CAA4BlC,IAA5B,CAAiC,IAAjC,EAAuCmB,KAAvC;;AAEA,QAAIgB,WAAW,GAAG,KAAKxD,WAAL,CAAiB8C,aAAjB,CAA+B,KAAKR,YAAL,CAAkBpB,OAAjD,EAA0D,CAA1D,CAAlB;AAEAsC,IAAAA,WAAW,CAACtD,UAAZ,GAAyB,IAAzB;AACH,GAPD;;AASAc,EAAAA,MAAM,CAACyC,sBAAP,GAAgC,YAAY;AACxC5B,IAAAA,WAAW,CAAC4B,sBAAZ,CAAmCpC,IAAnC,CAAwC,IAAxC;;AACA,SAAKiB,YAAL,CAAkBpB,OAAlB,CAA0BhB,UAA1B,GAAuC,IAAvC;AACH,GAHD,CAvF+B,CA4F/B;;;AACAc,EAAAA,MAAM,CAAC0C,kBAAP,GAA4B,UAAUlB,KAAV,EAAiBmB,MAAjB,EAAyB;AACjD9B,IAAAA,WAAW,CAAC6B,kBAAZ,CAA+BrC,IAA/B,CAAoC,IAApC,EAA0CmB,KAA1C,EAAiDmB,MAAjD;;AAEA,QAAIC,QAAQ,GAAG,KAAK5D,WAAL,CAAiB8C,aAAjB,CAA+Ba,MAA/B,CAAf;AAAA,QACIE,WAAW,GAAGD,QAAQ,CAACA,QAAQ,CAACZ,MAAT,GAAkB,CAAnB,CAD1B;AAGAa,IAAAA,WAAW,CAAC3D,UAAZ,GAAyBsC,KAAK,CAAClC,QAA/B;AACH,GAPD,CA7F+B,CAsG/B;;;AACAU,EAAAA,MAAM,CAAC8C,4BAAP,GAAsC,YAAY;AAC9C;AACA;AACA,SAAKzB,2BAAL,GAAmCR,WAAW,CAACiC,4BAAZ,CAAyCzC,IAAzC,CAA8C,IAA9C,CAAnC;AACA,WAAO,KAAKgB,2BAAZ;AACH,GALD;;AAOArB,EAAAA,MAAM,CAAC+C,iBAAP,GAA2B,UAAUvB,KAAV,EAAiB;AACxCX,IAAAA,WAAW,CAACkC,iBAAZ,CAA8B1C,IAA9B,CAAmC,IAAnC,EAAyCmB,KAAzC;;AAEA,QAAIwB,eAAe,GAAG,KAAKC,8BAAL,EAAtB;AAAA,QACIC,iBAAiB,GAAG,KAAK7B,2BAD7B;AAAA,QAEIsB,MAAM,GAAIK,eAAe,IAAIE,iBAAiB,CAACP,MAAtC,IACA,KAAKrB,YAAL,CAAkB6B,kBADlB,IAEA,KAAK7B,YAAL,CAAkBpB,OAJ/B;AAAA,QAKIkD,QAAQ,GAAG,KAAKpE,WAAL,CAAiB8C,aAAjB,CAA+Ba,MAA/B,CALf;AAAA,QAMIU,WAAW,GAAGL,eAAe,IAAIE,iBAAiB,CAACI,aAArC,GACAF,QAAQ,CAACG,OAAT,CAAiBL,iBAAiB,CAACI,aAAnC,IAAoD,CADpD,GAEAF,QAAQ,CAACpB,MAAT,GAAkB,CARpC;AAAA,QASIwB,QAAQ,GAAGJ,QAAQ,CAACC,WAAD,CATvB,CAHwC,CAcxC;;;AACA,QAAIG,QAAQ,CAACtE,UAAb,EACIsE,QAAQ,CAACtE,UAAT,CAAoBG,GAApB,GAA0BmC,KAAK,CAAClC,QAAN,CAAeD,GAAzC,CADJ,KAIImE,QAAQ,CAACtE,UAAT,GAAsBsC,KAAK,CAAClC,QAA5B;AACP,GApBD;AAqBH,CAnID","sourcesContent":["'use strict';\r\n\r\nvar OpenElementStack = require('./open_element_stack'),\r\n    Tokenizer = require('../tokenization/tokenizer'),\r\n    HTML = require('../common/html');\r\n\r\n\r\n//Aliases\r\nvar $ = HTML.TAG_NAMES;\r\n\r\n\r\nfunction setEndLocation(element, closingToken, treeAdapter) {\r\n    var loc = element.__location;\r\n\r\n    if (!loc)\r\n        return;\r\n\r\n    if (!loc.startTag) {\r\n        loc.startTag = {\r\n            start: loc.start,\r\n            end: loc.end\r\n        };\r\n    }\r\n\r\n    if (closingToken.location) {\r\n        var tn = treeAdapter.getTagName(element),\r\n            // NOTE: For cases like <p> <p> </p> - First 'p' closes without a closing tag and\r\n            // for cases like <td> <p> </td> - 'p' closes without a closing tag\r\n            isClosingEndTag = closingToken.type === Tokenizer.END_TAG_TOKEN &&\r\n                              tn === closingToken.tagName;\r\n\r\n        if (isClosingEndTag) {\r\n            loc.endTag = {\r\n                start: closingToken.location.start,\r\n                end: closingToken.location.end\r\n            };\r\n        }\r\n\r\n        loc.end = closingToken.location.end;\r\n    }\r\n}\r\n\r\n//NOTE: patch open elements stack, so we can assign end location for the elements\r\nfunction patchOpenElementsStack(stack, parser) {\r\n    var treeAdapter = parser.treeAdapter;\r\n\r\n    stack.pop = function () {\r\n        setEndLocation(this.current, parser.currentToken, treeAdapter);\r\n        OpenElementStack.prototype.pop.call(this);\r\n    };\r\n\r\n    stack.popAllUpToHtmlElement = function () {\r\n        for (var i = this.stackTop; i > 0; i--)\r\n            setEndLocation(this.items[i], parser.currentToken, treeAdapter);\r\n\r\n        OpenElementStack.prototype.popAllUpToHtmlElement.call(this);\r\n    };\r\n\r\n    stack.remove = function (element) {\r\n        setEndLocation(element, parser.currentToken, treeAdapter);\r\n        OpenElementStack.prototype.remove.call(this, element);\r\n    };\r\n}\r\n\r\nexports.assign = function (parser) {\r\n    //NOTE: obtain Parser proto this way to avoid module circular references\r\n    var parserProto = Object.getPrototypeOf(parser),\r\n        treeAdapter = parser.treeAdapter;\r\n\r\n\r\n    //NOTE: patch _reset method\r\n    parser._reset = function (html, document, fragmentContext) {\r\n        parserProto._reset.call(this, html, document, fragmentContext);\r\n\r\n        this.attachableElementLocation = null;\r\n        this.lastFosterParentingLocation = null;\r\n        this.currentToken = null;\r\n\r\n        patchOpenElementsStack(this.openElements, parser);\r\n    };\r\n\r\n    parser._processTokenInForeignContent = function (token) {\r\n        this.currentToken = token;\r\n        parserProto._processTokenInForeignContent.call(this, token);\r\n    };\r\n\r\n    parser._processToken = function (token) {\r\n        this.currentToken = token;\r\n        parserProto._processToken.call(this, token);\r\n\r\n        //NOTE: <body> and <html> are never popped from the stack, so we need to updated\r\n        //their end location explicitly.\r\n        if (token.type === Tokenizer.END_TAG_TOKEN &&\r\n            (token.tagName === $.HTML ||\r\n            (token.tagName === $.BODY && this.openElements.hasInScope($.BODY)))) {\r\n            for (var i = this.openElements.stackTop; i >= 0; i--) {\r\n                var element = this.openElements.items[i];\r\n\r\n                if (this.treeAdapter.getTagName(element) === token.tagName) {\r\n                    setEndLocation(element, token, treeAdapter);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    //Doctype\r\n    parser._setDocumentType = function (token) {\r\n        parserProto._setDocumentType.call(this, token);\r\n\r\n        var documentChildren = this.treeAdapter.getChildNodes(this.document),\r\n            cnLength = documentChildren.length;\r\n\r\n        for (var i = 0; i < cnLength; i++) {\r\n            var node = documentChildren[i];\r\n\r\n            if (this.treeAdapter.isDocumentTypeNode(node)) {\r\n                node.__location = token.location;\r\n                break;\r\n            }\r\n        }\r\n    };\r\n\r\n    //Elements\r\n    parser._attachElementToTree = function (element) {\r\n        //NOTE: _attachElementToTree is called from _appendElement, _insertElement and _insertTemplate methods.\r\n        //So we will use token location stored in this methods for the element.\r\n        element.__location = this.attachableElementLocation || null;\r\n        this.attachableElementLocation = null;\r\n        parserProto._attachElementToTree.call(this, element);\r\n    };\r\n\r\n    parser._appendElement = function (token, namespaceURI) {\r\n        this.attachableElementLocation = token.location;\r\n        parserProto._appendElement.call(this, token, namespaceURI);\r\n    };\r\n\r\n    parser._insertElement = function (token, namespaceURI) {\r\n        this.attachableElementLocation = token.location;\r\n        parserProto._insertElement.call(this, token, namespaceURI);\r\n    };\r\n\r\n    parser._insertTemplate = function (token) {\r\n        this.attachableElementLocation = token.location;\r\n        parserProto._insertTemplate.call(this, token);\r\n\r\n        var tmplContent = this.treeAdapter.getChildNodes(this.openElements.current)[0];\r\n\r\n        tmplContent.__location = null;\r\n    };\r\n\r\n    parser._insertFakeRootElement = function () {\r\n        parserProto._insertFakeRootElement.call(this);\r\n        this.openElements.current.__location = null;\r\n    };\r\n\r\n    //Comments\r\n    parser._appendCommentNode = function (token, parent) {\r\n        parserProto._appendCommentNode.call(this, token, parent);\r\n\r\n        var children = this.treeAdapter.getChildNodes(parent),\r\n            commentNode = children[children.length - 1];\r\n\r\n        commentNode.__location = token.location;\r\n    };\r\n\r\n    //Text\r\n    parser._findFosterParentingLocation = function () {\r\n        //NOTE: store last foster parenting location, so we will be able to find inserted text\r\n        //in case of foster parenting\r\n        this.lastFosterParentingLocation = parserProto._findFosterParentingLocation.call(this);\r\n        return this.lastFosterParentingLocation;\r\n    };\r\n\r\n    parser._insertCharacters = function (token) {\r\n        parserProto._insertCharacters.call(this, token);\r\n\r\n        var hasFosterParent = this._shouldFosterParentOnInsertion(),\r\n            parentingLocation = this.lastFosterParentingLocation,\r\n            parent = (hasFosterParent && parentingLocation.parent) ||\r\n                     this.openElements.currentTmplContent ||\r\n                     this.openElements.current,\r\n            siblings = this.treeAdapter.getChildNodes(parent),\r\n            textNodeIdx = hasFosterParent && parentingLocation.beforeElement ?\r\n                          siblings.indexOf(parentingLocation.beforeElement) - 1 :\r\n                          siblings.length - 1,\r\n            textNode = siblings[textNodeIdx];\r\n\r\n        //NOTE: if we have location assigned by another token, then just update end position\r\n        if (textNode.__location)\r\n            textNode.__location.end = token.location.end;\r\n\r\n        else\r\n            textNode.__location = token.location;\r\n    };\r\n};\r\n\r\n"]},"metadata":{},"sourceType":"script"}