{"ast":null,"code":"/** @preserve\r\n *  Copyright (c) 2014, Facebook, Inc.\r\n *  All rights reserved.\r\n *\r\n *  This source code is licensed under the BSD-style license found in the\r\n *  LICENSE file in the root directory of this source tree. An additional grant\r\n *  of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n */\n'use strict';\n/**\r\n * This is a very simple HTML to JSX converter. It turns out that browsers\r\n * have good HTML parsers (who would have thought?) so we utilise this by\r\n * inserting the HTML into a temporary DOM node, and then do a breadth-first\r\n * traversal of the resulting DOM tree.\r\n */\n// https://developer.mozilla.org/en-US/docs/Web/API/Node.nodeType\n\nvar NODE_TYPE = {\n  ELEMENT: 1,\n  TEXT: 3,\n  COMMENT: 8\n};\nvar ATTRIBUTE_MAPPING = {\n  'for': 'htmlFor',\n  'class': 'className'\n};\nvar ELEMENT_ATTRIBUTE_MAPPING = {\n  'input': {\n    'checked': 'defaultChecked',\n    'value': 'defaultValue'\n  }\n}; // Reference: https://developer.mozilla.org/en-US/docs/Web/SVG/Element#SVG_elements\n\nvar ELEMENT_TAG_NAME_MAPPING = {\n  a: 'a',\n  altglyph: 'altGlyph',\n  altglyphdef: 'altGlyphDef',\n  altglyphitem: 'altGlyphItem',\n  animate: 'animate',\n  animatecolor: 'animateColor',\n  animatemotion: 'animateMotion',\n  animatetransform: 'animateTransform',\n  audio: 'audio',\n  canvas: 'canvas',\n  circle: 'circle',\n  clippath: 'clipPath',\n  'color-profile': 'colorProfile',\n  cursor: 'cursor',\n  defs: 'defs',\n  desc: 'desc',\n  discard: 'discard',\n  ellipse: 'ellipse',\n  feblend: 'feBlend',\n  fecolormatrix: 'feColorMatrix',\n  fecomponenttransfer: 'feComponentTransfer',\n  fecomposite: 'feComposite',\n  feconvolvematrix: 'feConvolveMatrix',\n  fediffuselighting: 'feDiffuseLighting',\n  fedisplacementmap: 'feDisplacementMap',\n  fedistantlight: 'feDistantLight',\n  fedropshadow: 'feDropShadow',\n  feflood: 'feFlood',\n  fefunca: 'feFuncA',\n  fefuncb: 'feFuncB',\n  fefuncg: 'feFuncG',\n  fefuncr: 'feFuncR',\n  fegaussianblur: 'feGaussianBlur',\n  feimage: 'feImage',\n  femerge: 'feMerge',\n  femergenode: 'feMergeNode',\n  femorphology: 'feMorphology',\n  feoffset: 'feOffset',\n  fepointlight: 'fePointLight',\n  fespecularlighting: 'feSpecularLighting',\n  fespotlight: 'feSpotLight',\n  fetile: 'feTile',\n  feturbulence: 'feTurbulence',\n  filter: 'filter',\n  font: 'font',\n  'font-face': 'fontFace',\n  'font-face-format': 'fontFaceFormat',\n  'font-face-name': 'fontFaceName',\n  'font-face-src': 'fontFaceSrc',\n  'font-face-uri': 'fontFaceUri',\n  foreignobject: 'foreignObject',\n  g: 'g',\n  glyph: 'glyph',\n  glyphref: 'glyphRef',\n  hatch: 'hatch',\n  hatchpath: 'hatchpath',\n  hkern: 'hkern',\n  iframe: 'iframe',\n  image: 'image',\n  line: 'line',\n  lineargradient: 'linearGradient',\n  marker: 'marker',\n  mask: 'mask',\n  mesh: 'mesh',\n  meshgradient: 'meshgradient',\n  meshpatch: 'meshpatch',\n  meshrow: 'meshrow',\n  metadata: 'metadata',\n  'missing-glyph': 'missingGlyph',\n  mpath: 'mpath',\n  path: 'path',\n  pattern: 'pattern',\n  polygon: 'polygon',\n  polyline: 'polyline',\n  radialgradient: 'radialGradient',\n  rect: 'rect',\n  script: 'script',\n  set: 'set',\n  solidcolor: 'solidcolor',\n  stop: 'stop',\n  style: 'style',\n  svg: 'svg',\n  switch: 'switch',\n  symbol: 'symbol',\n  text: 'text',\n  textpath: 'textPath',\n  title: 'title',\n  tref: 'tref',\n  tspan: 'tspan',\n  unknown: 'unknown',\n  use: 'use',\n  video: 'video',\n  view: 'view',\n  vkern: 'vkern'\n};\n\nvar HTMLDOMPropertyConfig = require('react-dom/lib/HTMLDOMPropertyConfig');\n\nvar SVGDOMPropertyConfig = require('react-dom/lib/SVGDOMPropertyConfig');\n/**\r\n * Iterates over elements of object invokes iteratee for each element\r\n *\r\n * @param {object}   obj        Collection object\r\n * @param {function} iteratee   Callback function called in iterative processing\r\n * @param {any}      context    This arg (aka Context)\r\n */\n\n\nfunction eachObj(obj, iteratee, context) {\n  for (var key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      iteratee.call(context || obj, key, obj[key]);\n    }\n  }\n} // Populate property map with ReactJS's attribute and property mappings\n// TODO handle/use .Properties value eg: MUST_USE_PROPERTY is not HTML attr\n\n\nfunction mappingAttributesFromReactConfig(config) {\n  eachObj(config.Properties, function (propname) {\n    var mapFrom = config.DOMAttributeNames[propname] || propname.toLowerCase();\n    if (!ATTRIBUTE_MAPPING[mapFrom]) ATTRIBUTE_MAPPING[mapFrom] = propname;\n  });\n}\n\nmappingAttributesFromReactConfig(HTMLDOMPropertyConfig);\nmappingAttributesFromReactConfig(SVGDOMPropertyConfig);\n/**\r\n * Convert tag name to tag name suitable for JSX.\r\n *\r\n * @param  {string} tagName  String of tag name\r\n * @return {string}\r\n */\n\nfunction jsxTagName(tagName) {\n  var name = tagName.toLowerCase();\n\n  if (ELEMENT_TAG_NAME_MAPPING.hasOwnProperty(name)) {\n    name = ELEMENT_TAG_NAME_MAPPING[name];\n  }\n\n  return name;\n}\n/**\r\n * Repeats a string a certain number of times.\r\n * Also: the future is bright and consists of native string repetition:\r\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat\r\n *\r\n * @param {string} string  String to repeat\r\n * @param {number} times   Number of times to repeat string. Integer.\r\n * @see http://jsperf.com/string-repeater/2\r\n */\n\n\nfunction repeatString(string, times) {\n  if (times === 1) {\n    return string;\n  }\n\n  if (times < 0) {\n    throw new Error();\n  }\n\n  var repeated = '';\n\n  while (times) {\n    if (times & 1) {\n      repeated += string;\n    }\n\n    if (times >>= 1) {\n      string += string;\n    }\n  }\n\n  return repeated;\n}\n/**\r\n * Determine if the string ends with the specified substring.\r\n *\r\n * @param {string} haystack String to search in\r\n * @param {string} needle   String to search for\r\n * @return {boolean}\r\n */\n\n\nfunction endsWith(haystack, needle) {\n  return haystack.slice(-needle.length) === needle;\n}\n/**\r\n * Trim the specified substring off the string. If the string does not end\r\n * with the specified substring, this is a no-op.\r\n *\r\n * @param {string} haystack String to search in\r\n * @param {string} needle   String to search for\r\n * @return {string}\r\n */\n\n\nfunction trimEnd(haystack, needle) {\n  return endsWith(haystack, needle) ? haystack.slice(0, -needle.length) : haystack;\n}\n/**\r\n * Convert a hyphenated string to camelCase.\r\n */\n\n\nfunction hyphenToCamelCase(string) {\n  return string.replace(/-(.)/g, function (match, chr) {\n    return chr.toUpperCase();\n  });\n}\n/**\r\n * Determines if the specified string consists entirely of whitespace.\r\n */\n\n\nfunction isEmpty(string) {\n  return !/[^\\s]/.test(string);\n}\n/**\r\n * Determines if the CSS value can be converted from a\r\n * 'px' suffixed string to a numeric value\r\n *\r\n * @param {string} value CSS property value\r\n * @return {boolean}\r\n */\n\n\nfunction isConvertiblePixelValue(value) {\n  return /^\\d+px$/.test(value);\n}\n/**\r\n * Determines if the specified string consists entirely of numeric characters.\r\n */\n\n\nfunction isNumeric(input) {\n  return input !== undefined && input !== null && (typeof input === 'number' || parseInt(input, 10) == input);\n}\n\nvar createElement;\n\nif (typeof IN_BROWSER !== 'undefined' && IN_BROWSER) {\n  // Browser environment, use document.createElement directly.\n  createElement = function (tag) {\n    return document.createElement(tag);\n  };\n} else {\n  // Node.js-like environment, use jsdom.\n  var jsdom = require('jsdom-no-contextify').jsdom;\n\n  var window = jsdom().defaultView;\n\n  createElement = function (tag) {\n    return window.document.createElement(tag);\n  };\n}\n\nvar tempEl = createElement('div');\n/**\r\n * Escapes special characters by converting them to their escaped equivalent\r\n * (eg. \"<\" to \"&lt;\"). Only escapes characters that absolutely must be escaped.\r\n *\r\n * @param {string} value\r\n * @return {string}\r\n */\n\nfunction escapeSpecialChars(value) {\n  // Uses this One Weird Trick to escape text - Raw text inserted as textContent\n  // will have its escaped version in innerHTML.\n  tempEl.textContent = value;\n  return tempEl.innerHTML;\n}\n\nvar HTMLtoJSX = function (config) {\n  this.config = config || {};\n\n  if (this.config.createClass === undefined) {\n    this.config.createClass = true;\n  }\n\n  if (!this.config.indent) {\n    this.config.indent = '  ';\n  }\n};\n\nHTMLtoJSX.prototype = {\n  /**\r\n   * Reset the internal state of the converter\r\n   */\n  reset: function () {\n    this.output = '';\n    this.level = 0;\n    this._inPreTag = false;\n  },\n\n  /**\r\n   * Main entry point to the converter. Given the specified HTML, returns a\r\n   * JSX object representing it.\r\n   * @param {string} html HTML to convert\r\n   * @return {string} JSX\r\n   */\n  convert: function (html) {\n    this.reset();\n    var containerEl = createElement('div');\n    containerEl.innerHTML = '\\n' + this._cleanInput(html) + '\\n';\n\n    if (this.config.createClass) {\n      if (this.config.outputClassName) {\n        this.output = 'var ' + this.config.outputClassName + ' = React.createClass({\\n';\n      } else {\n        this.output = 'React.createClass({\\n';\n      }\n\n      this.output += this.config.indent + 'render: function() {' + \"\\n\";\n      this.output += this.config.indent + this.config.indent + 'return (\\n';\n    }\n\n    if (this._onlyOneTopLevel(containerEl)) {\n      // Only one top-level element, the component can return it directly\n      // No need to actually visit the container element\n      this._traverse(containerEl);\n    } else {\n      // More than one top-level element, need to wrap the whole thing in a\n      // container.\n      this.output += this.config.indent + this.config.indent + this.config.indent;\n      this.level++;\n\n      this._visit(containerEl);\n    }\n\n    this.output = this.output.trim() + '\\n';\n\n    if (this.config.createClass) {\n      this.output += this.config.indent + this.config.indent + ');\\n';\n      this.output += this.config.indent + '}\\n';\n      this.output += '});';\n    } else {\n      this.output = this._removeJSXClassIndention(this.output, this.config.indent);\n    }\n\n    return this.output;\n  },\n\n  /**\r\n   * Cleans up the specified HTML so it's in a format acceptable for\r\n   * converting.\r\n   *\r\n   * @param {string} html HTML to clean\r\n   * @return {string} Cleaned HTML\r\n   */\n  _cleanInput: function (html) {\n    // Remove unnecessary whitespace\n    html = html.trim(); // Ugly method to strip script tags. They can wreak havoc on the DOM nodes\n    // so let's not even put them in the DOM.\n\n    html = html.replace(/<script([\\s\\S]*?)<\\/script>/g, '');\n    return html;\n  },\n\n  /**\r\n   * Determines if there's only one top-level node in the DOM tree. That is,\r\n   * all the HTML is wrapped by a single HTML tag.\r\n   *\r\n   * @param {DOMElement} containerEl Container element\r\n   * @return {boolean}\r\n   */\n  _onlyOneTopLevel: function (containerEl) {\n    // Only a single child element\n    if (containerEl.childNodes.length === 1 && containerEl.childNodes[0].nodeType === NODE_TYPE.ELEMENT) {\n      return true;\n    } // Only one element, and all other children are whitespace\n\n\n    var foundElement = false;\n\n    for (var i = 0, count = containerEl.childNodes.length; i < count; i++) {\n      var child = containerEl.childNodes[i];\n\n      if (child.nodeType === NODE_TYPE.ELEMENT) {\n        if (foundElement) {\n          // Encountered an element after already encountering another one\n          // Therefore, more than one element at root level\n          return false;\n        } else {\n          foundElement = true;\n        }\n      } else if (child.nodeType === NODE_TYPE.TEXT && !isEmpty(child.textContent)) {\n        // Contains text content\n        return false;\n      }\n    }\n\n    return true;\n  },\n\n  /**\r\n   * Gets a newline followed by the correct indentation for the current\r\n   * nesting level\r\n   *\r\n   * @return {string}\r\n   */\n  _getIndentedNewline: function () {\n    return '\\n' + repeatString(this.config.indent, this.level + 2);\n  },\n\n  /**\r\n   * Handles processing the specified node\r\n   *\r\n   * @param {Node} node\r\n   */\n  _visit: function (node) {\n    this._beginVisit(node);\n\n    this._traverse(node);\n\n    this._endVisit(node);\n  },\n\n  /**\r\n   * Traverses all the children of the specified node\r\n   *\r\n   * @param {Node} node\r\n   */\n  _traverse: function (node) {\n    this.level++;\n\n    for (var i = 0, count = node.childNodes.length; i < count; i++) {\n      this._visit(node.childNodes[i]);\n    }\n\n    this.level--;\n  },\n\n  /**\r\n   * Handle pre-visit behaviour for the specified node.\r\n   *\r\n   * @param {Node} node\r\n   */\n  _beginVisit: function (node) {\n    switch (node.nodeType) {\n      case NODE_TYPE.ELEMENT:\n        this._beginVisitElement(node);\n\n        break;\n\n      case NODE_TYPE.TEXT:\n        this._visitText(node);\n\n        break;\n\n      case NODE_TYPE.COMMENT:\n        this._visitComment(node);\n\n        break;\n\n      default:\n        console.warn('Unrecognised node type: ' + node.nodeType);\n    }\n  },\n\n  /**\r\n   * Handles post-visit behaviour for the specified node.\r\n   *\r\n   * @param {Node} node\r\n   */\n  _endVisit: function (node) {\n    switch (node.nodeType) {\n      case NODE_TYPE.ELEMENT:\n        this._endVisitElement(node);\n\n        break;\n      // No ending tags required for these types\n\n      case NODE_TYPE.TEXT:\n      case NODE_TYPE.COMMENT:\n        break;\n    }\n  },\n\n  /**\r\n   * Handles pre-visit behaviour for the specified element node\r\n   *\r\n   * @param {DOMElement} node\r\n   */\n  _beginVisitElement: function (node) {\n    var tagName = jsxTagName(node.tagName);\n    var attributes = [];\n\n    for (var i = 0, count = node.attributes.length; i < count; i++) {\n      attributes.push(this._getElementAttribute(node, node.attributes[i]));\n    }\n\n    if (tagName === 'textarea') {\n      // Hax: textareas need their inner text moved to a \"defaultValue\" attribute.\n      attributes.push('defaultValue={' + JSON.stringify(node.value) + '}');\n    }\n\n    if (tagName === 'style') {\n      // Hax: style tag contents need to be dangerously set due to liberal curly brace usage\n      attributes.push('dangerouslySetInnerHTML={{__html: ' + JSON.stringify(node.textContent) + ' }}');\n    }\n\n    if (tagName === 'pre') {\n      this._inPreTag = true;\n    }\n\n    this.output += '<' + tagName;\n\n    if (attributes.length > 0) {\n      this.output += ' ' + attributes.join(' ');\n    }\n\n    if (!this._isSelfClosing(node)) {\n      this.output += '>';\n    }\n  },\n\n  /**\r\n   * Handles post-visit behaviour for the specified element node\r\n   *\r\n   * @param {Node} node\r\n   */\n  _endVisitElement: function (node) {\n    var tagName = jsxTagName(node.tagName); // De-indent a bit\n    // TODO: It's inefficient to do it this way :/\n\n    this.output = trimEnd(this.output, this.config.indent);\n\n    if (this._isSelfClosing(node)) {\n      this.output += ' />';\n    } else {\n      this.output += '</' + tagName + '>';\n    }\n\n    if (tagName === 'pre') {\n      this._inPreTag = false;\n    }\n  },\n\n  /**\r\n   * Determines if this element node should be rendered as a self-closing\r\n   * tag.\r\n   *\r\n   * @param {Node} node\r\n   * @return {boolean}\r\n   */\n  _isSelfClosing: function (node) {\n    var tagName = jsxTagName(node.tagName); // If it has children, it's not self-closing\n    // Exception: All children of a textarea are moved to a \"defaultValue\" attribute, style attributes are dangerously set.\n\n    return !node.firstChild || tagName === 'textarea' || tagName === 'style';\n  },\n\n  /**\r\n   * Handles processing of the specified text node\r\n   *\r\n   * @param {TextNode} node\r\n   */\n  _visitText: function (node) {\n    var parentTag = node.parentNode && jsxTagName(node.parentNode.tagName);\n\n    if (parentTag === 'textarea' || parentTag === 'style') {\n      // Ignore text content of textareas and styles, as it will have already been moved\n      // to a \"defaultValue\" attribute and \"dangerouslySetInnerHTML\" attribute respectively.\n      return;\n    }\n\n    var text = escapeSpecialChars(node.textContent);\n\n    if (this._inPreTag) {\n      // If this text is contained within a <pre>, we need to ensure the JSX\n      // whitespace coalescing rules don't eat the whitespace. This means\n      // wrapping newlines and sequences of two or more spaces in variables.\n      text = text.replace(/\\r/g, '').replace(/( {2,}|\\n|\\t|\\{|\\})/g, function (whitespace) {\n        return '{' + JSON.stringify(whitespace) + '}';\n      });\n    } else {\n      // Handle any curly braces.\n      text = text.replace(/(\\{|\\})/g, function (brace) {\n        return '{\\'' + brace + '\\'}';\n      }); // If there's a newline in the text, adjust the indent level\n\n      if (text.indexOf('\\n') > -1) {\n        text = text.replace(/\\n\\s*/g, this._getIndentedNewline());\n      }\n    }\n\n    this.output += text;\n  },\n\n  /**\r\n   * Handles processing of the specified text node\r\n   *\r\n   * @param {Text} node\r\n   */\n  _visitComment: function (node) {\n    this.output += '{/*' + node.textContent.replace('*/', '* /') + '*/}';\n  },\n\n  /**\r\n   * Gets a JSX formatted version of the specified attribute from the node\r\n   *\r\n   * @param {DOMElement} node\r\n   * @param {object}     attribute\r\n   * @return {string}\r\n   */\n  _getElementAttribute: function (node, attribute) {\n    switch (attribute.name) {\n      case 'style':\n        return this._getStyleAttribute(attribute.value);\n\n      default:\n        var tagName = jsxTagName(node.tagName);\n        var name = ELEMENT_ATTRIBUTE_MAPPING[tagName] && ELEMENT_ATTRIBUTE_MAPPING[tagName][attribute.name] || ATTRIBUTE_MAPPING[attribute.name] || attribute.name;\n        var result = name; // Numeric values should be output as {123} not \"123\"\n\n        if (isNumeric(attribute.value)) {\n          result += '={' + attribute.value + '}';\n        } else if (attribute.value.length > 0) {\n          result += '=\"' + attribute.value.replace(/\"/gm, '&quot;') + '\"';\n        }\n\n        return result;\n    }\n  },\n\n  /**\r\n   * Gets a JSX formatted version of the specified element styles\r\n   *\r\n   * @param {string} styles\r\n   * @return {string}\r\n   */\n  _getStyleAttribute: function (styles) {\n    var jsxStyles = new StyleParser(styles).toJSXString();\n    return 'style={{' + jsxStyles + '}}';\n  },\n\n  /**\r\n   * Removes class-level indention in the JSX output. To be used when the JSX\r\n   * output is configured to not contain a class deifinition.\r\n   *\r\n   * @param {string} output JSX output with class-level indention\r\n   * @param {string} indent Configured indention\r\n   * @return {string} JSX output wihtout class-level indention\r\n   */\n  _removeJSXClassIndention: function (output, indent) {\n    var classIndention = new RegExp('\\\\n' + indent + indent + indent, 'g');\n    return output.replace(classIndention, '\\n');\n  }\n};\n/**\r\n * Handles parsing of inline styles\r\n *\r\n * @param {string} rawStyle Raw style attribute\r\n * @constructor\r\n */\n\nvar StyleParser = function (rawStyle) {\n  this.parse(rawStyle);\n};\n\nStyleParser.prototype = {\n  /**\r\n   * Parse the specified inline style attribute value\r\n   * @param {string} rawStyle Raw style attribute\r\n   */\n  parse: function (rawStyle) {\n    this.styles = {};\n    rawStyle.split(';').forEach(function (style) {\n      style = style.trim();\n      var firstColon = style.indexOf(':');\n      var key = style.substr(0, firstColon);\n      var value = style.substr(firstColon + 1).trim();\n\n      if (key !== '') {\n        // Style key should be case insensitive\n        key = key.toLowerCase();\n        this.styles[key] = value;\n      }\n    }, this);\n  },\n\n  /**\r\n   * Convert the style information represented by this parser into a JSX\r\n   * string\r\n   *\r\n   * @return {string}\r\n   */\n  toJSXString: function () {\n    var output = [];\n    eachObj(this.styles, function (key, value) {\n      output.push(this.toJSXKey(key) + ': ' + this.toJSXValue(value));\n    }, this);\n    return output.join(', ');\n  },\n\n  /**\r\n   * Convert the CSS style key to a JSX style key\r\n   *\r\n   * @param {string} key CSS style key\r\n   * @return {string} JSX style key\r\n   */\n  toJSXKey: function (key) {\n    // Don't capitalize -ms- prefix\n    if (/^-ms-/.test(key)) {\n      key = key.substr(1);\n    }\n\n    return hyphenToCamelCase(key);\n  },\n\n  /**\r\n   * Convert the CSS style value to a JSX style value\r\n   *\r\n   * @param {string} value CSS style value\r\n   * @return {string} JSX style value\r\n   */\n  toJSXValue: function (value) {\n    if (isNumeric(value)) {\n      // If numeric, no quotes\n      return value;\n    } else if (isConvertiblePixelValue(value)) {\n      // \"500px\" -> 500\n      return trimEnd(value, 'px');\n    } else {\n      // Probably a string, wrap it in quotes\n      return '\\'' + value.replace(/'/g, '\"') + '\\'';\n    }\n  }\n};\nmodule.exports = HTMLtoJSX;","map":{"version":3,"sources":["F:/JavaScript/Projects/chemistryphile/node_modules/htmltojsx/src/htmltojsx.js"],"names":["NODE_TYPE","ELEMENT","TEXT","COMMENT","ATTRIBUTE_MAPPING","ELEMENT_ATTRIBUTE_MAPPING","ELEMENT_TAG_NAME_MAPPING","a","altglyph","altglyphdef","altglyphitem","animate","animatecolor","animatemotion","animatetransform","audio","canvas","circle","clippath","cursor","defs","desc","discard","ellipse","feblend","fecolormatrix","fecomponenttransfer","fecomposite","feconvolvematrix","fediffuselighting","fedisplacementmap","fedistantlight","fedropshadow","feflood","fefunca","fefuncb","fefuncg","fefuncr","fegaussianblur","feimage","femerge","femergenode","femorphology","feoffset","fepointlight","fespecularlighting","fespotlight","fetile","feturbulence","filter","font","foreignobject","g","glyph","glyphref","hatch","hatchpath","hkern","iframe","image","line","lineargradient","marker","mask","mesh","meshgradient","meshpatch","meshrow","metadata","mpath","path","pattern","polygon","polyline","radialgradient","rect","script","set","solidcolor","stop","style","svg","switch","symbol","text","textpath","title","tref","tspan","unknown","use","video","view","vkern","HTMLDOMPropertyConfig","require","SVGDOMPropertyConfig","eachObj","obj","iteratee","context","key","hasOwnProperty","call","mappingAttributesFromReactConfig","config","Properties","propname","mapFrom","DOMAttributeNames","toLowerCase","jsxTagName","tagName","name","repeatString","string","times","Error","repeated","endsWith","haystack","needle","slice","length","trimEnd","hyphenToCamelCase","replace","match","chr","toUpperCase","isEmpty","test","isConvertiblePixelValue","value","isNumeric","input","undefined","parseInt","createElement","IN_BROWSER","tag","document","jsdom","window","defaultView","tempEl","escapeSpecialChars","textContent","innerHTML","HTMLtoJSX","createClass","indent","prototype","reset","output","level","_inPreTag","convert","html","containerEl","_cleanInput","outputClassName","_onlyOneTopLevel","_traverse","_visit","trim","_removeJSXClassIndention","childNodes","nodeType","foundElement","i","count","child","_getIndentedNewline","node","_beginVisit","_endVisit","_beginVisitElement","_visitText","_visitComment","console","warn","_endVisitElement","attributes","push","_getElementAttribute","JSON","stringify","join","_isSelfClosing","firstChild","parentTag","parentNode","whitespace","brace","indexOf","attribute","_getStyleAttribute","result","styles","jsxStyles","StyleParser","toJSXString","classIndention","RegExp","rawStyle","parse","split","forEach","firstColon","substr","toJSXKey","toJSXValue","module","exports"],"mappings":"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","sourcesContent":["/** @preserve\r\n *  Copyright (c) 2014, Facebook, Inc.\r\n *  All rights reserved.\r\n *\r\n *  This source code is licensed under the BSD-style license found in the\r\n *  LICENSE file in the root directory of this source tree. An additional grant\r\n *  of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n */\r\n'use strict';\r\n\r\n/**\r\n * This is a very simple HTML to JSX converter. It turns out that browsers\r\n * have good HTML parsers (who would have thought?) so we utilise this by\r\n * inserting the HTML into a temporary DOM node, and then do a breadth-first\r\n * traversal of the resulting DOM tree.\r\n */\r\n\r\n// https://developer.mozilla.org/en-US/docs/Web/API/Node.nodeType\r\nvar NODE_TYPE = {\r\n  ELEMENT: 1,\r\n  TEXT: 3,\r\n  COMMENT: 8\r\n};\r\n\r\nvar ATTRIBUTE_MAPPING = {\r\n  'for': 'htmlFor',\r\n  'class': 'className'\r\n};\r\n\r\nvar ELEMENT_ATTRIBUTE_MAPPING = {\r\n  'input': {\r\n    'checked': 'defaultChecked',\r\n    'value': 'defaultValue'\r\n  }\r\n};\r\n\r\n// Reference: https://developer.mozilla.org/en-US/docs/Web/SVG/Element#SVG_elements\r\nvar ELEMENT_TAG_NAME_MAPPING = {\r\n  a: 'a',\r\n  altglyph: 'altGlyph',\r\n  altglyphdef: 'altGlyphDef',\r\n  altglyphitem: 'altGlyphItem',\r\n  animate: 'animate',\r\n  animatecolor: 'animateColor',\r\n  animatemotion: 'animateMotion',\r\n  animatetransform: 'animateTransform',\r\n  audio: 'audio',\r\n  canvas: 'canvas',\r\n  circle: 'circle',\r\n  clippath: 'clipPath',\r\n  'color-profile': 'colorProfile',\r\n  cursor: 'cursor',\r\n  defs: 'defs',\r\n  desc: 'desc',\r\n  discard: 'discard',\r\n  ellipse: 'ellipse',\r\n  feblend: 'feBlend',\r\n  fecolormatrix: 'feColorMatrix',\r\n  fecomponenttransfer: 'feComponentTransfer',\r\n  fecomposite: 'feComposite',\r\n  feconvolvematrix: 'feConvolveMatrix',\r\n  fediffuselighting: 'feDiffuseLighting',\r\n  fedisplacementmap: 'feDisplacementMap',\r\n  fedistantlight: 'feDistantLight',\r\n  fedropshadow: 'feDropShadow',\r\n  feflood: 'feFlood',\r\n  fefunca: 'feFuncA',\r\n  fefuncb: 'feFuncB',\r\n  fefuncg: 'feFuncG',\r\n  fefuncr: 'feFuncR',\r\n  fegaussianblur: 'feGaussianBlur',\r\n  feimage: 'feImage',\r\n  femerge: 'feMerge',\r\n  femergenode: 'feMergeNode',\r\n  femorphology: 'feMorphology',\r\n  feoffset: 'feOffset',\r\n  fepointlight: 'fePointLight',\r\n  fespecularlighting: 'feSpecularLighting',\r\n  fespotlight: 'feSpotLight',\r\n  fetile: 'feTile',\r\n  feturbulence: 'feTurbulence',\r\n  filter: 'filter',\r\n  font: 'font',\r\n  'font-face': 'fontFace',\r\n  'font-face-format': 'fontFaceFormat',\r\n  'font-face-name': 'fontFaceName',\r\n  'font-face-src': 'fontFaceSrc',\r\n  'font-face-uri': 'fontFaceUri',\r\n  foreignobject: 'foreignObject',\r\n  g: 'g',\r\n  glyph: 'glyph',\r\n  glyphref: 'glyphRef',\r\n  hatch: 'hatch',\r\n  hatchpath: 'hatchpath',\r\n  hkern: 'hkern',\r\n  iframe: 'iframe',\r\n  image: 'image',\r\n  line: 'line',\r\n  lineargradient: 'linearGradient',\r\n  marker: 'marker',\r\n  mask: 'mask',\r\n  mesh: 'mesh',\r\n  meshgradient: 'meshgradient',\r\n  meshpatch: 'meshpatch',\r\n  meshrow: 'meshrow',\r\n  metadata: 'metadata',\r\n  'missing-glyph': 'missingGlyph',\r\n  mpath: 'mpath',\r\n  path: 'path',\r\n  pattern: 'pattern',\r\n  polygon: 'polygon',\r\n  polyline: 'polyline',\r\n  radialgradient: 'radialGradient',\r\n  rect: 'rect',\r\n  script: 'script',\r\n  set: 'set',\r\n  solidcolor: 'solidcolor',\r\n  stop: 'stop',\r\n  style: 'style',\r\n  svg: 'svg',\r\n  switch: 'switch',\r\n  symbol: 'symbol',\r\n  text: 'text',\r\n  textpath: 'textPath',\r\n  title: 'title',\r\n  tref: 'tref',\r\n  tspan: 'tspan',\r\n  unknown: 'unknown',\r\n  use: 'use',\r\n  video: 'video',\r\n  view: 'view',\r\n  vkern: 'vkern'\r\n};\r\n\r\nvar HTMLDOMPropertyConfig = require('react-dom/lib/HTMLDOMPropertyConfig');\r\nvar SVGDOMPropertyConfig = require('react-dom/lib/SVGDOMPropertyConfig');\r\n\r\n/**\r\n * Iterates over elements of object invokes iteratee for each element\r\n *\r\n * @param {object}   obj        Collection object\r\n * @param {function} iteratee   Callback function called in iterative processing\r\n * @param {any}      context    This arg (aka Context)\r\n */\r\nfunction eachObj(obj, iteratee, context) {\r\n  for (var key in obj) {\r\n    if (obj.hasOwnProperty(key)) {\r\n      iteratee.call(context || obj, key, obj[key]);\r\n    }\r\n  }\r\n}\r\n\r\n// Populate property map with ReactJS's attribute and property mappings\r\n// TODO handle/use .Properties value eg: MUST_USE_PROPERTY is not HTML attr\r\nfunction mappingAttributesFromReactConfig(config) {\r\n  eachObj(config.Properties, function(propname) {\r\n    var mapFrom = config.DOMAttributeNames[propname] || propname.toLowerCase();\r\n\r\n    if (!ATTRIBUTE_MAPPING[mapFrom])\r\n      ATTRIBUTE_MAPPING[mapFrom] = propname;\r\n  });\r\n}\r\n\r\nmappingAttributesFromReactConfig(HTMLDOMPropertyConfig);\r\nmappingAttributesFromReactConfig(SVGDOMPropertyConfig);\r\n\r\n/**\r\n * Convert tag name to tag name suitable for JSX.\r\n *\r\n * @param  {string} tagName  String of tag name\r\n * @return {string}\r\n */\r\nfunction jsxTagName(tagName) {\r\n  var name = tagName.toLowerCase();\r\n\r\n  if (ELEMENT_TAG_NAME_MAPPING.hasOwnProperty(name)) {\r\n    name = ELEMENT_TAG_NAME_MAPPING[name];\r\n  }\r\n\r\n  return name;\r\n}\r\n\r\n/**\r\n * Repeats a string a certain number of times.\r\n * Also: the future is bright and consists of native string repetition:\r\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat\r\n *\r\n * @param {string} string  String to repeat\r\n * @param {number} times   Number of times to repeat string. Integer.\r\n * @see http://jsperf.com/string-repeater/2\r\n */\r\nfunction repeatString(string, times) {\r\n  if (times === 1) {\r\n    return string;\r\n  }\r\n  if (times < 0) { throw new Error(); }\r\n  var repeated = '';\r\n  while (times) {\r\n    if (times & 1) {\r\n      repeated += string;\r\n    }\r\n    if (times >>= 1) {\r\n      string += string;\r\n    }\r\n  }\r\n  return repeated;\r\n}\r\n\r\n/**\r\n * Determine if the string ends with the specified substring.\r\n *\r\n * @param {string} haystack String to search in\r\n * @param {string} needle   String to search for\r\n * @return {boolean}\r\n */\r\nfunction endsWith(haystack, needle) {\r\n  return haystack.slice(-needle.length) === needle;\r\n}\r\n\r\n/**\r\n * Trim the specified substring off the string. If the string does not end\r\n * with the specified substring, this is a no-op.\r\n *\r\n * @param {string} haystack String to search in\r\n * @param {string} needle   String to search for\r\n * @return {string}\r\n */\r\nfunction trimEnd(haystack, needle) {\r\n  return endsWith(haystack, needle)\r\n    ? haystack.slice(0, -needle.length)\r\n    : haystack;\r\n}\r\n\r\n/**\r\n * Convert a hyphenated string to camelCase.\r\n */\r\nfunction hyphenToCamelCase(string) {\r\n  return string.replace(/-(.)/g, function(match, chr) {\r\n    return chr.toUpperCase();\r\n  });\r\n}\r\n\r\n/**\r\n * Determines if the specified string consists entirely of whitespace.\r\n */\r\nfunction isEmpty(string) {\r\n   return !/[^\\s]/.test(string);\r\n}\r\n\r\n/**\r\n * Determines if the CSS value can be converted from a\r\n * 'px' suffixed string to a numeric value\r\n *\r\n * @param {string} value CSS property value\r\n * @return {boolean}\r\n */\r\nfunction isConvertiblePixelValue(value) {\r\n  return /^\\d+px$/.test(value);\r\n}\r\n\r\n/**\r\n * Determines if the specified string consists entirely of numeric characters.\r\n */\r\nfunction isNumeric(input) {\r\n  return input !== undefined\r\n    && input !== null\r\n    && (typeof input === 'number' || parseInt(input, 10) == input);\r\n}\r\n\r\nvar createElement;\r\nif (typeof IN_BROWSER !== 'undefined' && IN_BROWSER) {\r\n  // Browser environment, use document.createElement directly.\r\n  createElement = function(tag) {\r\n    return document.createElement(tag);\r\n  };\r\n} else {\r\n  // Node.js-like environment, use jsdom.\r\n  var jsdom = require('jsdom-no-contextify').jsdom;\r\n  var window = jsdom().defaultView;\r\n  createElement = function(tag) {\r\n    return window.document.createElement(tag);\r\n  };\r\n}\r\n\r\nvar tempEl = createElement('div');\r\n/**\r\n * Escapes special characters by converting them to their escaped equivalent\r\n * (eg. \"<\" to \"&lt;\"). Only escapes characters that absolutely must be escaped.\r\n *\r\n * @param {string} value\r\n * @return {string}\r\n */\r\nfunction escapeSpecialChars(value) {\r\n  // Uses this One Weird Trick to escape text - Raw text inserted as textContent\r\n  // will have its escaped version in innerHTML.\r\n  tempEl.textContent = value;\r\n  return tempEl.innerHTML;\r\n}\r\n\r\nvar HTMLtoJSX = function(config) {\r\n  this.config = config || {};\r\n\r\n  if (this.config.createClass === undefined) {\r\n    this.config.createClass = true;\r\n  }\r\n  if (!this.config.indent) {\r\n    this.config.indent = '  ';\r\n  }\r\n};\r\nHTMLtoJSX.prototype = {\r\n  /**\r\n   * Reset the internal state of the converter\r\n   */\r\n  reset: function() {\r\n    this.output = '';\r\n    this.level = 0;\r\n    this._inPreTag = false;\r\n  },\r\n  /**\r\n   * Main entry point to the converter. Given the specified HTML, returns a\r\n   * JSX object representing it.\r\n   * @param {string} html HTML to convert\r\n   * @return {string} JSX\r\n   */\r\n  convert: function(html) {\r\n    this.reset();\r\n\r\n    var containerEl = createElement('div');\r\n    containerEl.innerHTML = '\\n' + this._cleanInput(html) + '\\n';\r\n\r\n    if (this.config.createClass) {\r\n      if (this.config.outputClassName) {\r\n        this.output = 'var ' + this.config.outputClassName + ' = React.createClass({\\n';\r\n      } else {\r\n        this.output = 'React.createClass({\\n';\r\n      }\r\n      this.output += this.config.indent + 'render: function() {' + \"\\n\";\r\n      this.output += this.config.indent + this.config.indent + 'return (\\n';\r\n    }\r\n\r\n    if (this._onlyOneTopLevel(containerEl)) {\r\n      // Only one top-level element, the component can return it directly\r\n      // No need to actually visit the container element\r\n      this._traverse(containerEl);\r\n    } else {\r\n      // More than one top-level element, need to wrap the whole thing in a\r\n      // container.\r\n      this.output += this.config.indent + this.config.indent + this.config.indent;\r\n      this.level++;\r\n      this._visit(containerEl);\r\n    }\r\n    this.output = this.output.trim() + '\\n';\r\n    if (this.config.createClass) {\r\n      this.output += this.config.indent + this.config.indent + ');\\n';\r\n      this.output += this.config.indent + '}\\n';\r\n      this.output += '});';\r\n    } else {\r\n      this.output = this._removeJSXClassIndention(this.output, this.config.indent);\r\n    }\r\n    return this.output;\r\n  },\r\n\r\n  /**\r\n   * Cleans up the specified HTML so it's in a format acceptable for\r\n   * converting.\r\n   *\r\n   * @param {string} html HTML to clean\r\n   * @return {string} Cleaned HTML\r\n   */\r\n  _cleanInput: function(html) {\r\n    // Remove unnecessary whitespace\r\n    html = html.trim();\r\n    // Ugly method to strip script tags. They can wreak havoc on the DOM nodes\r\n    // so let's not even put them in the DOM.\r\n    html = html.replace(/<script([\\s\\S]*?)<\\/script>/g, '');\r\n    return html;\r\n  },\r\n\r\n  /**\r\n   * Determines if there's only one top-level node in the DOM tree. That is,\r\n   * all the HTML is wrapped by a single HTML tag.\r\n   *\r\n   * @param {DOMElement} containerEl Container element\r\n   * @return {boolean}\r\n   */\r\n  _onlyOneTopLevel: function(containerEl) {\r\n    // Only a single child element\r\n    if (\r\n      containerEl.childNodes.length === 1\r\n      && containerEl.childNodes[0].nodeType === NODE_TYPE.ELEMENT\r\n    ) {\r\n      return true;\r\n    }\r\n    // Only one element, and all other children are whitespace\r\n    var foundElement = false;\r\n    for (var i = 0, count = containerEl.childNodes.length; i < count; i++) {\r\n      var child = containerEl.childNodes[i];\r\n      if (child.nodeType === NODE_TYPE.ELEMENT) {\r\n        if (foundElement) {\r\n          // Encountered an element after already encountering another one\r\n          // Therefore, more than one element at root level\r\n          return false;\r\n        } else {\r\n          foundElement = true;\r\n        }\r\n      } else if (child.nodeType === NODE_TYPE.TEXT && !isEmpty(child.textContent)) {\r\n        // Contains text content\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  },\r\n\r\n  /**\r\n   * Gets a newline followed by the correct indentation for the current\r\n   * nesting level\r\n   *\r\n   * @return {string}\r\n   */\r\n  _getIndentedNewline: function() {\r\n    return '\\n' + repeatString(this.config.indent, this.level + 2);\r\n  },\r\n\r\n  /**\r\n   * Handles processing the specified node\r\n   *\r\n   * @param {Node} node\r\n   */\r\n  _visit: function(node) {\r\n    this._beginVisit(node);\r\n    this._traverse(node);\r\n    this._endVisit(node);\r\n  },\r\n\r\n  /**\r\n   * Traverses all the children of the specified node\r\n   *\r\n   * @param {Node} node\r\n   */\r\n  _traverse: function(node) {\r\n    this.level++;\r\n    for (var i = 0, count = node.childNodes.length; i < count; i++) {\r\n      this._visit(node.childNodes[i]);\r\n    }\r\n    this.level--;\r\n  },\r\n\r\n  /**\r\n   * Handle pre-visit behaviour for the specified node.\r\n   *\r\n   * @param {Node} node\r\n   */\r\n  _beginVisit: function(node) {\r\n    switch (node.nodeType) {\r\n      case NODE_TYPE.ELEMENT:\r\n        this._beginVisitElement(node);\r\n        break;\r\n\r\n      case NODE_TYPE.TEXT:\r\n        this._visitText(node);\r\n        break;\r\n\r\n      case NODE_TYPE.COMMENT:\r\n        this._visitComment(node);\r\n        break;\r\n\r\n      default:\r\n        console.warn('Unrecognised node type: ' + node.nodeType);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Handles post-visit behaviour for the specified node.\r\n   *\r\n   * @param {Node} node\r\n   */\r\n  _endVisit: function(node) {\r\n    switch (node.nodeType) {\r\n      case NODE_TYPE.ELEMENT:\r\n        this._endVisitElement(node);\r\n        break;\r\n      // No ending tags required for these types\r\n      case NODE_TYPE.TEXT:\r\n      case NODE_TYPE.COMMENT:\r\n        break;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Handles pre-visit behaviour for the specified element node\r\n   *\r\n   * @param {DOMElement} node\r\n   */\r\n  _beginVisitElement: function(node) {\r\n    var tagName = jsxTagName(node.tagName);\r\n    var attributes = [];\r\n    for (var i = 0, count = node.attributes.length; i < count; i++) {\r\n      attributes.push(this._getElementAttribute(node, node.attributes[i]));\r\n    }\r\n\r\n    if (tagName === 'textarea') {\r\n      // Hax: textareas need their inner text moved to a \"defaultValue\" attribute.\r\n      attributes.push('defaultValue={' + JSON.stringify(node.value) + '}');\r\n    }\r\n    if (tagName === 'style') {\r\n      // Hax: style tag contents need to be dangerously set due to liberal curly brace usage\r\n      attributes.push('dangerouslySetInnerHTML={{__html: ' + JSON.stringify(node.textContent) + ' }}');\r\n    }\r\n    if (tagName === 'pre') {\r\n      this._inPreTag = true;\r\n    }\r\n\r\n    this.output += '<' + tagName;\r\n    if (attributes.length > 0) {\r\n      this.output += ' ' + attributes.join(' ');\r\n    }\r\n    if (!this._isSelfClosing(node)) {\r\n      this.output += '>';\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Handles post-visit behaviour for the specified element node\r\n   *\r\n   * @param {Node} node\r\n   */\r\n  _endVisitElement: function(node) {\r\n    var tagName = jsxTagName(node.tagName);\r\n    // De-indent a bit\r\n    // TODO: It's inefficient to do it this way :/\r\n    this.output = trimEnd(this.output, this.config.indent);\r\n    if (this._isSelfClosing(node)) {\r\n      this.output += ' />';\r\n    } else {\r\n      this.output += '</' + tagName + '>';\r\n    }\r\n\r\n    if (tagName === 'pre') {\r\n      this._inPreTag = false;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Determines if this element node should be rendered as a self-closing\r\n   * tag.\r\n   *\r\n   * @param {Node} node\r\n   * @return {boolean}\r\n   */\r\n  _isSelfClosing: function(node) {\r\n    var tagName = jsxTagName(node.tagName);\r\n    // If it has children, it's not self-closing\r\n    // Exception: All children of a textarea are moved to a \"defaultValue\" attribute, style attributes are dangerously set.\r\n    return !node.firstChild || tagName === 'textarea' || tagName === 'style';\r\n  },\r\n\r\n  /**\r\n   * Handles processing of the specified text node\r\n   *\r\n   * @param {TextNode} node\r\n   */\r\n  _visitText: function(node) {\r\n    var parentTag = node.parentNode && jsxTagName(node.parentNode.tagName);\r\n    if (parentTag === 'textarea' || parentTag === 'style') {\r\n      // Ignore text content of textareas and styles, as it will have already been moved\r\n      // to a \"defaultValue\" attribute and \"dangerouslySetInnerHTML\" attribute respectively.\r\n      return;\r\n    }\r\n\r\n    var text = escapeSpecialChars(node.textContent);\r\n\r\n    if (this._inPreTag) {\r\n      // If this text is contained within a <pre>, we need to ensure the JSX\r\n      // whitespace coalescing rules don't eat the whitespace. This means\r\n      // wrapping newlines and sequences of two or more spaces in variables.\r\n      text = text\r\n        .replace(/\\r/g, '')\r\n        .replace(/( {2,}|\\n|\\t|\\{|\\})/g, function(whitespace) {\r\n          return '{' + JSON.stringify(whitespace) + '}';\r\n        });\r\n    } else {\r\n      // Handle any curly braces.\r\n      text = text\r\n        .replace(/(\\{|\\})/g, function(brace) {\r\n            return '{\\'' + brace + '\\'}';\r\n        });\r\n      // If there's a newline in the text, adjust the indent level\r\n      if (text.indexOf('\\n') > -1) {\r\n        text = text.replace(/\\n\\s*/g, this._getIndentedNewline());\r\n      }\r\n    }\r\n    this.output += text;\r\n  },\r\n\r\n  /**\r\n   * Handles processing of the specified text node\r\n   *\r\n   * @param {Text} node\r\n   */\r\n  _visitComment: function(node) {\r\n    this.output += '{/*' + node.textContent.replace('*/', '* /') + '*/}';\r\n  },\r\n\r\n  /**\r\n   * Gets a JSX formatted version of the specified attribute from the node\r\n   *\r\n   * @param {DOMElement} node\r\n   * @param {object}     attribute\r\n   * @return {string}\r\n   */\r\n  _getElementAttribute: function(node, attribute) {\r\n    switch (attribute.name) {\r\n      case 'style':\r\n        return this._getStyleAttribute(attribute.value);\r\n      default:\r\n        var tagName = jsxTagName(node.tagName);\r\n        var name =\r\n          (ELEMENT_ATTRIBUTE_MAPPING[tagName] &&\r\n            ELEMENT_ATTRIBUTE_MAPPING[tagName][attribute.name]) ||\r\n          ATTRIBUTE_MAPPING[attribute.name] ||\r\n          attribute.name;\r\n        var result = name;\r\n\r\n        // Numeric values should be output as {123} not \"123\"\r\n        if (isNumeric(attribute.value)) {\r\n          result += '={' + attribute.value + '}';\r\n        } else if (attribute.value.length > 0) {\r\n          result += '=\"' + attribute.value.replace(/\"/gm, '&quot;') + '\"';\r\n        }\r\n        return result;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Gets a JSX formatted version of the specified element styles\r\n   *\r\n   * @param {string} styles\r\n   * @return {string}\r\n   */\r\n  _getStyleAttribute: function(styles) {\r\n    var jsxStyles = new StyleParser(styles).toJSXString();\r\n    return 'style={{' + jsxStyles + '}}';\r\n  },\r\n\r\n  /**\r\n   * Removes class-level indention in the JSX output. To be used when the JSX\r\n   * output is configured to not contain a class deifinition.\r\n   *\r\n   * @param {string} output JSX output with class-level indention\r\n   * @param {string} indent Configured indention\r\n   * @return {string} JSX output wihtout class-level indention\r\n   */\r\n  _removeJSXClassIndention: function(output, indent) {\r\n    var classIndention = new RegExp('\\\\n' + indent + indent + indent,  'g');\r\n    return output.replace(classIndention, '\\n');\r\n  }\r\n};\r\n\r\n/**\r\n * Handles parsing of inline styles\r\n *\r\n * @param {string} rawStyle Raw style attribute\r\n * @constructor\r\n */\r\nvar StyleParser = function(rawStyle) {\r\n  this.parse(rawStyle);\r\n};\r\nStyleParser.prototype = {\r\n  /**\r\n   * Parse the specified inline style attribute value\r\n   * @param {string} rawStyle Raw style attribute\r\n   */\r\n  parse: function(rawStyle) {\r\n    this.styles = {};\r\n    rawStyle.split(';').forEach(function(style) {\r\n      style = style.trim();\r\n      var firstColon = style.indexOf(':');\r\n      var key = style.substr(0, firstColon);\r\n      var value = style.substr(firstColon + 1).trim();\r\n      if (key !== '') {\r\n        // Style key should be case insensitive\r\n        key = key.toLowerCase();\r\n        this.styles[key] = value;\r\n      }\r\n    }, this);\r\n  },\r\n\r\n  /**\r\n   * Convert the style information represented by this parser into a JSX\r\n   * string\r\n   *\r\n   * @return {string}\r\n   */\r\n  toJSXString: function() {\r\n    var output = [];\r\n    eachObj(this.styles, function(key, value) {\r\n      output.push(this.toJSXKey(key) + ': ' + this.toJSXValue(value));\r\n    }, this);\r\n    return output.join(', ');\r\n  },\r\n\r\n  /**\r\n   * Convert the CSS style key to a JSX style key\r\n   *\r\n   * @param {string} key CSS style key\r\n   * @return {string} JSX style key\r\n   */\r\n  toJSXKey: function(key) {\r\n    // Don't capitalize -ms- prefix\r\n    if(/^-ms-/.test(key)) {\r\n      key = key.substr(1);\r\n    }\r\n    return hyphenToCamelCase(key);\r\n  },\r\n\r\n  /**\r\n   * Convert the CSS style value to a JSX style value\r\n   *\r\n   * @param {string} value CSS style value\r\n   * @return {string} JSX style value\r\n   */\r\n  toJSXValue: function(value) {\r\n    if (isNumeric(value)) {\r\n      // If numeric, no quotes\r\n      return value;\r\n    } else if (isConvertiblePixelValue(value)) {\r\n      // \"500px\" -> 500\r\n      return trimEnd(value, 'px');\r\n    } else {\r\n      // Probably a string, wrap it in quotes\r\n      return '\\'' + value.replace(/'/g, '\"') + '\\'';\r\n    }\r\n  }\r\n};\r\n\r\nmodule.exports = HTMLtoJSX;\r\n"]},"metadata":{},"sourceType":"script"}