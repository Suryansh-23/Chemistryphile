{"ast":null,"code":"var parse5 = require('parse5');\n\nvar htmlparser2 = require('htmlparser2');\n\nfunction HtmlToDom(parser, parsingMode) {\n  if (!parser) {\n    if (parsingMode === \"xml\") {\n      parser = htmlparser2;\n    } else {\n      parser = parse5;\n    }\n  }\n\n  if (parser.DefaultHandler || parser.Parser && parser.TreeAdapters) {\n    // Forgiving HTML parser\n    if (parser.DefaultHandler) {\n      // fb55/htmlparser2\n      parser.ParseHtml = function (rawHtml) {\n        var handler = new parser.DefaultHandler(); // Check if document is XML\n\n        var isXML = parsingMode === \"xml\";\n        var parserInstance = new parser.Parser(handler, {\n          xmlMode: isXML,\n          lowerCaseTags: !isXML,\n          lowerCaseAttributeNames: !isXML,\n          decodeEntities: true\n        });\n        parserInstance.includeLocation = false;\n        parserInstance.parseComplete(rawHtml);\n        return handler.dom;\n      };\n    } else if (parser.Parser && parser.TreeAdapters) {\n      parser.ParseHtml = function (rawHtml) {\n        if (parsingMode === 'xml') {\n          throw new Error('Can\\'t parse XML with parse5, please use htmlparser2 instead.');\n        }\n\n        var instance = new parser.Parser(parser.TreeAdapters.htmlparser2);\n        var dom = instance.parse(rawHtml);\n        return dom.children;\n      };\n    }\n\n    this.appendHtmlToElement = function (html, element) {\n      if (typeof html !== 'string') {\n        html += '';\n      }\n\n      var parsed = parser.ParseHtml(html);\n\n      for (var i = 0; i < parsed.length; i++) {\n        setChild(element, parsed[i]);\n      }\n\n      return element;\n    };\n\n    this.appendHtmlToDocument = this.appendHtmlToElement;\n\n    if (parser.Parser && parser.TreeAdapters) {\n      this.appendHtmlToElement = function (html, element) {\n        if (typeof html !== 'string') {\n          html += '';\n        }\n\n        var instance = new parser.Parser(parser.TreeAdapters.htmlparser2);\n        var parentElement = parser.TreeAdapters.htmlparser2.createElement(element.tagName.toLowerCase(), element.namespaceURI, []);\n        var dom = instance.parseFragment(html, parentElement);\n        var parsed = dom.children;\n\n        for (var i = 0; i < parsed.length; i++) {\n          setChild(element, parsed[i]);\n        }\n\n        return element;\n      };\n    }\n  } else if (parser.moduleName == 'HTML5') {\n    /* HTML5 parser */\n    this.appendHtmlToElement = function (html, element) {\n      if (typeof html !== 'string') {\n        html += '';\n      }\n\n      if (html.length > 0) {\n        if (element.nodeType == 9) {\n          new parser.Parser({\n            document: element\n          }).parse(html);\n        } else {\n          var p = new parser.Parser({\n            document: element.ownerDocument\n          });\n          p.parse_fragment(html, element);\n        }\n      }\n    };\n  } else {\n    this.appendHtmlToElement = function () {\n      console.log('');\n      console.log('###########################################################');\n      console.log('#  WARNING: No compatible HTML parser was given.');\n      console.log('#  Element.innerHTML setter support has been disabled');\n      console.log('#  Element.innerHTML getter support will still function');\n      console.log('###########################################################');\n      console.log('');\n    };\n  }\n}\n\n; // utility function for forgiving parser\n\nfunction setChild(parent, node) {\n  var c,\n      newNode,\n      currentDocument = parent._ownerDocument || parent;\n\n  switch (node.type) {\n    case 'tag':\n    case 'script':\n    case 'style':\n      try {\n        newNode = currentDocument._createElementNoTagNameValidation(node.name);\n        newNode._namespaceURI = node.namespace || \"http://www.w3.org/1999/xhtml\";\n\n        if (node.location) {\n          newNode.sourceLocation = node.location;\n          newNode.sourceLocation.file = parent.sourceLocation.file;\n        }\n      } catch (err) {\n        currentDocument.raise('error', 'invalid markup', {\n          exception: err,\n          node: node\n        });\n        return null;\n      }\n\n      break;\n\n    case 'root':\n      // If we are in <template> then implicitly create #document-fragment for it's content\n      if (parent.tagName === 'TEMPLATE' && parent._namespaceURI === 'http://www.w3.org/1999/xhtml') {\n        newNode = currentDocument.createDocumentFragment(); // Mark fragment as parser-created template content, so it will be accepted by appendChild()\n\n        newNode._templateContent = true;\n      }\n\n      break;\n\n    case 'text':\n      // HTML entities should already be decoded by the parser, so no need to decode them\n      newNode = currentDocument.createTextNode(node.data);\n      break;\n\n    case 'comment':\n      newNode = currentDocument.createComment(node.data);\n      break;\n\n    case 'directive':\n      if (node.name[0] === '?' && node.name.toLowerCase() !== '?xml') {\n        var data = node.data.slice(node.name.length + 1, -1);\n        newNode = currentDocument.createProcessingInstruction(node.name.substring(1), data);\n      } else if (node.name.toLowerCase() === '!doctype') {\n        newNode = parseDocType(currentDocument, '<' + node.data + '>');\n      }\n\n      break;\n\n    default:\n      return null;\n      break;\n  }\n\n  if (!newNode) return null;\n  newNode._localName = node.name;\n\n  if (node.attribs) {\n    for (c in node.attribs) {\n      var prefix = node['x-attribsPrefix'] && node['x-attribsPrefix'][c] ? node['x-attribsPrefix'][c] + ':' : ''; // catchin errors here helps with improperly escaped attributes\n      // but properly fixing parent should (can only?) be done in the htmlparser itself\n\n      try {\n        newNode._setAttributeNoValidation(prefix + c, node.attribs[c]);\n\n        newNode.attributes[prefix + c]._namespaceURI = node['x-attribsNamespace'][c] || null;\n        newNode.attributes[prefix + c]._prefix = node['x-attribsPrefix'][c] || null;\n        newNode.attributes[prefix + c]._localName = c;\n      } catch (e2) {\n        /* noop */\n      }\n    }\n  }\n\n  if (node.children) {\n    for (c = 0; c < node.children.length; c++) {\n      setChild(newNode, node.children[c]);\n    }\n  }\n\n  try {\n    return parent.appendChild(newNode);\n  } catch (err) {\n    currentDocument.raise('error', err.message, {\n      exception: err,\n      node: node\n    });\n    return null;\n  }\n}\n\nvar HTML5_DOCTYPE = /<!doctype html>/i;\nvar PUBLIC_DOCTYPE = /<!doctype\\s+([^\\s]+)\\s+public\\s+\"([^\"]+)\"\\s+\"([^\"]+)\"/i;\nvar SYSTEM_DOCTYPE = /<!doctype\\s+([^\\s]+)\\s+system\\s+\"([^\"]+)\"/i;\n\nfunction parseDocType(doc, html) {\n  if (HTML5_DOCTYPE.test(html)) {\n    return doc.implementation.createDocumentType(\"html\", \"\", \"\");\n  }\n\n  var publicPieces = PUBLIC_DOCTYPE.exec(html);\n\n  if (publicPieces) {\n    return doc.implementation.createDocumentType(publicPieces[1], publicPieces[2], publicPieces[3]);\n  }\n\n  var systemPieces = SYSTEM_DOCTYPE.exec(html);\n\n  if (systemPieces) {\n    return doc.implementation.createDocumentType(systemPieces[1], systemPieces[2], \"\");\n  } // Shouldn't get here (the parser shouldn't let us know about invalid doctypes), but our logic likely isn't\n  // real-world perfect, so let's fallback.\n\n\n  return doc.implementation.createDocumentType(\"html\", \"\", \"\");\n}\n\nexports.HtmlToDom = HtmlToDom;","map":{"version":3,"sources":["F:/JavaScript/Projects/chemistryphile/node_modules/jsdom-no-contextify/lib/jsdom/browser/htmltodom.js"],"names":["parse5","require","htmlparser2","HtmlToDom","parser","parsingMode","DefaultHandler","Parser","TreeAdapters","ParseHtml","rawHtml","handler","isXML","parserInstance","xmlMode","lowerCaseTags","lowerCaseAttributeNames","decodeEntities","includeLocation","parseComplete","dom","Error","instance","parse","children","appendHtmlToElement","html","element","parsed","i","length","setChild","appendHtmlToDocument","parentElement","createElement","tagName","toLowerCase","namespaceURI","parseFragment","moduleName","nodeType","document","p","ownerDocument","parse_fragment","console","log","parent","node","c","newNode","currentDocument","_ownerDocument","type","_createElementNoTagNameValidation","name","_namespaceURI","namespace","location","sourceLocation","file","err","raise","exception","createDocumentFragment","_templateContent","createTextNode","data","createComment","slice","createProcessingInstruction","substring","parseDocType","_localName","attribs","prefix","_setAttributeNoValidation","attributes","_prefix","e2","appendChild","message","HTML5_DOCTYPE","PUBLIC_DOCTYPE","SYSTEM_DOCTYPE","doc","test","implementation","createDocumentType","publicPieces","exec","systemPieces","exports"],"mappings":"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","sourcesContent":["var parse5 = require('parse5');\nvar htmlparser2 = require('htmlparser2');\n\nfunction HtmlToDom(parser, parsingMode) {\n  if (!parser) {\n    if (parsingMode === \"xml\") {\n      parser = htmlparser2;\n    } else {\n      parser = parse5;\n    }\n  }\n\n  if (parser.DefaultHandler || (parser.Parser && parser.TreeAdapters)) {\n\n    // Forgiving HTML parser\n\n    if (parser.DefaultHandler){\n      // fb55/htmlparser2\n\n      parser.ParseHtml = function(rawHtml) {\n        var handler = new parser.DefaultHandler();\n        // Check if document is XML\n        var isXML = parsingMode === \"xml\";\n        var parserInstance = new parser.Parser(handler, {\n          xmlMode: isXML,\n          lowerCaseTags: !isXML,\n          lowerCaseAttributeNames: !isXML,\n          decodeEntities: true\n        });\n\n        parserInstance.includeLocation = false;\n        parserInstance.parseComplete(rawHtml);\n        return handler.dom;\n      };\n    } else if (parser.Parser && parser.TreeAdapters) {\n      parser.ParseHtml = function (rawHtml) {\n        if (parsingMode === 'xml') {\n          throw new Error('Can\\'t parse XML with parse5, please use htmlparser2 instead.');\n        }\n        var instance = new parser.Parser(parser.TreeAdapters.htmlparser2);\n        var dom = instance.parse(rawHtml);\n        return dom.children;\n      };\n    }\n\n    this.appendHtmlToElement = function(html, element) {\n\n      if (typeof html !== 'string') {\n        html +='';\n      }\n\n      var parsed = parser.ParseHtml(html);\n\n      for (var i = 0; i < parsed.length; i++) {\n        setChild(element, parsed[i]);\n      }\n\n      return element;\n    };\n    this.appendHtmlToDocument = this.appendHtmlToElement;\n\n    if (parser.Parser && parser.TreeAdapters) {\n      this.appendHtmlToElement = function (html, element) {\n\n        if (typeof html !== 'string') {\n          html += '';\n        }\n\n        var instance = new parser.Parser(parser.TreeAdapters.htmlparser2);\n        var parentElement = parser.TreeAdapters.htmlparser2.createElement(element.tagName.toLowerCase(), element.namespaceURI, []);\n        var dom = instance.parseFragment(html, parentElement);\n        var parsed = dom.children;\n\n        for (var i = 0; i < parsed.length; i++) {\n          setChild(element, parsed[i]);\n        }\n\n        return element;\n      };\n    }\n\n  } else if (parser.moduleName == 'HTML5') { /* HTML5 parser */\n    this.appendHtmlToElement = function(html, element) {\n\n      if (typeof html !== 'string') {\n        html += '';\n      }\n      if (html.length > 0) {\n        if (element.nodeType == 9) {\n          new parser.Parser({document: element}).parse(html);\n        }\n        else {\n          var p = new parser.Parser({document: element.ownerDocument});\n          p.parse_fragment(html, element);\n        }\n      }\n    };\n  } else {\n    this.appendHtmlToElement = function () {\n      console.log('');\n      console.log('###########################################################');\n      console.log('#  WARNING: No compatible HTML parser was given.');\n      console.log('#  Element.innerHTML setter support has been disabled');\n      console.log('#  Element.innerHTML getter support will still function');\n      console.log('###########################################################');\n      console.log('');\n    };\n  }\n};\n\n// utility function for forgiving parser\nfunction setChild(parent, node) {\n\n  var c, newNode, currentDocument = parent._ownerDocument || parent;\n\n  switch (node.type)\n  {\n    case 'tag':\n    case 'script':\n    case 'style':\n      try {\n        newNode = currentDocument._createElementNoTagNameValidation(node.name);\n        newNode._namespaceURI = node.namespace || \"http://www.w3.org/1999/xhtml\";\n        if (node.location) {\n          newNode.sourceLocation = node.location;\n          newNode.sourceLocation.file = parent.sourceLocation.file;\n        }\n      } catch (err) {\n        currentDocument.raise('error', 'invalid markup', {\n          exception: err,\n          node : node\n        });\n\n        return null;\n      }\n    break;\n\n    case 'root':\n        // If we are in <template> then implicitly create #document-fragment for it's content\n        if(parent.tagName === 'TEMPLATE' && parent._namespaceURI === 'http://www.w3.org/1999/xhtml') {\n            newNode = currentDocument.createDocumentFragment();\n            // Mark fragment as parser-created template content, so it will be accepted by appendChild()\n            newNode._templateContent = true;\n        }\n    break;\n\n    case 'text':\n      // HTML entities should already be decoded by the parser, so no need to decode them\n      newNode = currentDocument.createTextNode(node.data);\n    break;\n\n    case 'comment':\n      newNode = currentDocument.createComment(node.data);\n    break;\n\n    case 'directive':\n      if (node.name[0] === '?' && node.name.toLowerCase() !== '?xml') {\n        var data = node.data.slice(node.name.length + 1, -1);\n        newNode = currentDocument.createProcessingInstruction(node.name.substring(1), data);\n      } else if (node.name.toLowerCase() === '!doctype') {\n        newNode = parseDocType(currentDocument, '<' + node.data + '>');\n      }\n    break;\n\n    default:\n      return null;\n    break;\n  }\n\n  if (!newNode)\n    return null;\n\n  newNode._localName = node.name;\n\n  if (node.attribs) {\n    for (c in node.attribs) {\n      var prefix = node['x-attribsPrefix'] && node['x-attribsPrefix'][c] ? node['x-attribsPrefix'][c] + ':' : '';\n      // catchin errors here helps with improperly escaped attributes\n      // but properly fixing parent should (can only?) be done in the htmlparser itself\n      try {\n        newNode._setAttributeNoValidation(prefix + c, node.attribs[c]);\n        newNode.attributes[prefix + c]._namespaceURI = node['x-attribsNamespace'][c] || null;\n        newNode.attributes[prefix + c]._prefix = node['x-attribsPrefix'][c] || null;\n        newNode.attributes[prefix + c]._localName = c;\n      } catch(e2) { /* noop */ }\n    }\n  }\n\n  if (node.children) {\n    for (c = 0; c < node.children.length; c++) {\n      setChild(newNode, node.children[c]);\n    }\n  }\n\n  try{\n    return parent.appendChild(newNode);\n  }catch(err){\n    currentDocument.raise('error', err.message, {\n          exception: err,\n          node : node\n        });\n    return null;\n  }\n}\n\nvar HTML5_DOCTYPE = /<!doctype html>/i;\nvar PUBLIC_DOCTYPE = /<!doctype\\s+([^\\s]+)\\s+public\\s+\"([^\"]+)\"\\s+\"([^\"]+)\"/i;\nvar SYSTEM_DOCTYPE = /<!doctype\\s+([^\\s]+)\\s+system\\s+\"([^\"]+)\"/i;\n\nfunction parseDocType(doc, html) {\n  if (HTML5_DOCTYPE.test(html)) {\n    return doc.implementation.createDocumentType(\"html\", \"\", \"\");\n  }\n\n  var publicPieces = PUBLIC_DOCTYPE.exec(html);\n  if (publicPieces) {\n    return doc.implementation.createDocumentType(publicPieces[1], publicPieces[2], publicPieces[3]);\n  }\n\n  var systemPieces = SYSTEM_DOCTYPE.exec(html);\n  if (systemPieces) {\n    return doc.implementation.createDocumentType(systemPieces[1], systemPieces[2], \"\");\n  }\n\n  // Shouldn't get here (the parser shouldn't let us know about invalid doctypes), but our logic likely isn't\n  // real-world perfect, so let's fallback.\n  return doc.implementation.createDocumentType(\"html\", \"\", \"\");\n}\n\n\nexports.HtmlToDom = HtmlToDom;\n"]},"metadata":{},"sourceType":"script"}