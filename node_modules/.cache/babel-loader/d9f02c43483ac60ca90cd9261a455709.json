{"ast":null,"code":"\"use strict\";\n\nvar defineGetter = require(\"../utils\").defineGetter;\n\nmodule.exports = function (core) {\n  var DOCUMENT_POSITION_DISCONNECTED = core.Node.DOCUMENT_POSITION_DISCONNECTED;\n  var DOCUMENT_POSITION_PRECEDING = core.Node.DOCUMENT_POSITION_PRECEDING;\n  var DOCUMENT_POSITION_FOLLOWING = core.Node.DOCUMENT_POSITION_FOLLOWING;\n  var DOCUMENT_POSITION_CONTAINS = core.Node.DOCUMENT_POSITION_CONTAINS;\n  var DOCUMENT_POSITION_CONTAINED_BY = core.Node.DOCUMENT_POSITION_CONTAINED_BY;\n  var DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = core.Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC;\n  /**\n   * Return true if node is of a type obsoleted by the WHATWG living standard\n   * @param  {Node}  node\n   * @return {Boolean}\n   */\n\n  function isObsoleteNodeType(node) {\n    return node.nodeType === core.Node.ENTITY_NODE || node.nodeType === core.Node.ENTITY_REFERENCE_NODE || node.nodeType === core.Node.NOTATION_NODE || node.nodeType === core.Node.CDATA_SECTION_NODE;\n  }\n  /**\n   * Return the parent node of node, whatever its nodeType is\n   * @param  {Node} node\n   * @return {Node or null}\n   */\n\n\n  function getNodeParent(node) {\n    if (!node) {\n      return node;\n    }\n\n    switch (node.nodeType) {\n      case core.Node.DOCUMENT_NODE:\n      case core.Node.DOCUMENT_FRAGMENT_NODE:\n        return null;\n\n      case core.Node.COMMENT_NODE:\n      case core.Node.DOCUMENT_TYPE_NODE:\n      case core.Node.ELEMENT_NODE:\n      case core.Node.PROCESSING_INSTRUCTION_NODE:\n      case core.Node.TEXT_NODE:\n        return node.parentNode;\n\n      case core.Node.ATTRIBUTE_NODE:\n        return node._parentNode;\n\n      default:\n        throw new Error(\"Unknown node type:\" + node.nodeType);\n    }\n  }\n  /**\n   * Walk up the node tree and return the nodes root node\n   * @param  {Node} node\n   * @return {Node}\n   */\n\n\n  function findNodeRoot(node) {\n    if (!getNodeParent(node)) {\n      return node;\n    }\n\n    return findNodeRoot(getNodeParent(node));\n  }\n  /**\n   * Walk up the node tree returning true if otherNode is an ancestor of node\n   * @param  {Node}  node\n   * @param  {Node}  otherNode\n   * @return {Boolean}\n   */\n\n\n  function isAncestor(node, otherNode) {\n    var parentNode = node.nodeType === node.ATTRIBUTE_NODE ? node._parentNode : node.parentNode;\n\n    if (!parentNode) {\n      return false;\n    }\n\n    if (parentNode === otherNode) {\n      return true;\n    }\n\n    return isAncestor(parentNode, otherNode);\n  }\n  /**\n   * Traverse the node tree starting at current. Return DOCUMENT_POSITION_FOLLOWING if otherNode follows node. Return\n   * DOCUMENT_POSITION_PRECEDING if otherNode precedes node\n   * @param  {Node} current\n   * @param  {Node} node\n   * @param  {Node} otherNode\n   * @return {Number}\n   */\n\n\n  function followingOrPreceding(current, node, otherNode) {\n    if (current === node) {\n      return core.Node.DOCUMENT_POSITION_FOLLOWING;\n    }\n\n    if (current === otherNode) {\n      return core.Node.DOCUMENT_POSITION_PRECEDING;\n    }\n\n    var i = 0,\n        len = current._childNodes.length,\n        child,\n        result;\n\n    for (; i < len; i += 1) {\n      child = current._childNodes[i];\n\n      if ((result = followingOrPreceding(child, node, otherNode)) !== 0) {\n        return result;\n      }\n    }\n\n    return 0;\n  }\n  /**\n   * Returns a bitmask Number composed of DOCUMENT_POSITION constants based upon the rules defined in\n   * http://dom.spec.whatwg.org/#dom-node-comparedocumentposition\n   * @param  {Node} other\n   * @return {Number}\n   */\n\n\n  core.Node.prototype.compareDocumentPosition = function compareDocumentPosition(other) {\n    // Let reference be the context object.\n    var reference = this;\n\n    if (!(other instanceof core.Node)) {\n      throw Error(\"Comparing position against non-Node values is not allowed\");\n    }\n\n    if (isObsoleteNodeType(reference) || isObsoleteNodeType(other)) {\n      throw new Error(\"Obsolete node type\");\n    } // If other and reference are the same object, return zero.\n\n\n    if (reference.isSameNode(other)) {\n      return 0;\n    } // If other and reference are not in the same tree, return the result of adding DOCUMENT_POSITION_DISCONNECTED,\n    // DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC, and either DOCUMENT_POSITION_PRECEDING or DOCUMENT_POSITION_FOLLOWING,\n    // with the constraint that this is to be consistent, together.\n\n\n    if (findNodeRoot(reference) !== findNodeRoot(other)) {\n      return DOCUMENT_POSITION_DISCONNECTED + DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC + DOCUMENT_POSITION_FOLLOWING;\n    } // If other is an ancestor of reference, return the result of adding DOCUMENT_POSITION_CONTAINS to\n    // DOCUMENT_POSITION_PRECEDING.\n\n\n    if (isAncestor(reference, other)) {\n      return DOCUMENT_POSITION_CONTAINS + DOCUMENT_POSITION_PRECEDING;\n    } // If other is a descendant of reference, return the result of adding DOCUMENT_POSITION_CONTAINED_BY to\n    // DOCUMENT_POSITION_FOLLOWING.\n\n\n    if (isAncestor(other, reference)) {\n      return DOCUMENT_POSITION_CONTAINED_BY + DOCUMENT_POSITION_FOLLOWING;\n    } // If other is preceding reference return DOCUMENT_POSITION_PRECEDING, otherwise return DOCUMENT_POSITION_FOLLOWING\n\n\n    return followingOrPreceding(findNodeRoot(reference), reference, other);\n  };\n  /**\n   * The contains(other) method returns true if other is an inclusive descendant of the context object,\n   * and false otherwise (including when other is null).\n   * @param  {[Node]} other [the node to test]\n   * @return {[boolean]}      [whether other is an inclusive descendant of this]\n   */\n\n\n  core.Node.prototype.contains = function (other) {\n    return other instanceof core.Node && (this.isSameNode(other) || !!(this.compareDocumentPosition(other) & DOCUMENT_POSITION_CONTAINED_BY));\n  }; // http://dom.spec.whatwg.org/#dom-node-parentelement\n\n\n  defineGetter(core.Node.prototype, \"parentElement\", function () {\n    return this._parentNode !== null && this._parentNode.nodeType === core.Node.ELEMENT_NODE ? this._parentNode : null;\n  });\n};","map":{"version":3,"sources":["F:/JavaScript/Projects/chemistryphile/node_modules/jsdom-no-contextify/lib/jsdom/living/node.js"],"names":["defineGetter","require","module","exports","core","DOCUMENT_POSITION_DISCONNECTED","Node","DOCUMENT_POSITION_PRECEDING","DOCUMENT_POSITION_FOLLOWING","DOCUMENT_POSITION_CONTAINS","DOCUMENT_POSITION_CONTAINED_BY","DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC","isObsoleteNodeType","node","nodeType","ENTITY_NODE","ENTITY_REFERENCE_NODE","NOTATION_NODE","CDATA_SECTION_NODE","getNodeParent","DOCUMENT_NODE","DOCUMENT_FRAGMENT_NODE","COMMENT_NODE","DOCUMENT_TYPE_NODE","ELEMENT_NODE","PROCESSING_INSTRUCTION_NODE","TEXT_NODE","parentNode","ATTRIBUTE_NODE","_parentNode","Error","findNodeRoot","isAncestor","otherNode","followingOrPreceding","current","i","len","_childNodes","length","child","result","prototype","compareDocumentPosition","other","reference","isSameNode","contains"],"mappings":"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","sourcesContent":["\"use strict\";\nvar defineGetter = require(\"../utils\").defineGetter;\n\nmodule.exports = function (core) {\n  var DOCUMENT_POSITION_DISCONNECTED = core.Node.DOCUMENT_POSITION_DISCONNECTED;\n  var DOCUMENT_POSITION_PRECEDING = core.Node.DOCUMENT_POSITION_PRECEDING;\n  var DOCUMENT_POSITION_FOLLOWING = core.Node.DOCUMENT_POSITION_FOLLOWING;\n  var DOCUMENT_POSITION_CONTAINS = core.Node.DOCUMENT_POSITION_CONTAINS;\n  var DOCUMENT_POSITION_CONTAINED_BY = core.Node.DOCUMENT_POSITION_CONTAINED_BY;\n  var DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = core.Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC;\n\n  /**\n   * Return true if node is of a type obsoleted by the WHATWG living standard\n   * @param  {Node}  node\n   * @return {Boolean}\n   */\n  function isObsoleteNodeType(node) {\n    return node.nodeType === core.Node.ENTITY_NODE ||\n      node.nodeType === core.Node.ENTITY_REFERENCE_NODE ||\n      node.nodeType === core.Node.NOTATION_NODE ||\n      node.nodeType === core.Node.CDATA_SECTION_NODE;\n  }\n\n  /**\n   * Return the parent node of node, whatever its nodeType is\n   * @param  {Node} node\n   * @return {Node or null}\n   */\n  function getNodeParent(node) {\n\n    if(!node) {\n      return node;\n    }\n\n    switch (node.nodeType) {\n\n      case core.Node.DOCUMENT_NODE:\n      case core.Node.DOCUMENT_FRAGMENT_NODE:\n        return null;\n\n      case core.Node.COMMENT_NODE:\n      case core.Node.DOCUMENT_TYPE_NODE:\n      case core.Node.ELEMENT_NODE:\n      case core.Node.PROCESSING_INSTRUCTION_NODE:\n      case core.Node.TEXT_NODE:\n        return node.parentNode;\n\n      case core.Node.ATTRIBUTE_NODE:\n\n        return node._parentNode;\n\n      default:\n        throw new Error(\"Unknown node type:\" + node.nodeType);\n    }\n  }\n\n  /**\n   * Walk up the node tree and return the nodes root node\n   * @param  {Node} node\n   * @return {Node}\n   */\n  function findNodeRoot(node) {\n    if (!getNodeParent(node)) {\n      return node;\n    }\n\n    return findNodeRoot(getNodeParent(node));\n  }\n\n  /**\n   * Walk up the node tree returning true if otherNode is an ancestor of node\n   * @param  {Node}  node\n   * @param  {Node}  otherNode\n   * @return {Boolean}\n   */\n  function isAncestor(node, otherNode) {\n    var parentNode = node.nodeType === node.ATTRIBUTE_NODE ? node._parentNode : node.parentNode;\n\n    if (!parentNode) {\n      return false;\n    }\n\n    if(parentNode === otherNode) {\n      return true;\n    }\n\n    return isAncestor(parentNode, otherNode);\n  }\n\n  /**\n   * Traverse the node tree starting at current. Return DOCUMENT_POSITION_FOLLOWING if otherNode follows node. Return\n   * DOCUMENT_POSITION_PRECEDING if otherNode precedes node\n   * @param  {Node} current\n   * @param  {Node} node\n   * @param  {Node} otherNode\n   * @return {Number}\n   */\n  function followingOrPreceding(current, node, otherNode) {\n    if (current === node) {\n      return core.Node.DOCUMENT_POSITION_FOLLOWING;\n    }\n\n    if (current === otherNode) {\n      return core.Node.DOCUMENT_POSITION_PRECEDING;\n    }\n\n    var i = 0, len = current._childNodes.length, child, result;\n\n    for(; i < len; i += 1) {\n\n      child = current._childNodes[i];\n\n      if((result = followingOrPreceding(child, node, otherNode)) !== 0) {\n        return result;\n      }\n    }\n\n    return 0;\n  }\n\n  /**\n   * Returns a bitmask Number composed of DOCUMENT_POSITION constants based upon the rules defined in\n   * http://dom.spec.whatwg.org/#dom-node-comparedocumentposition\n   * @param  {Node} other\n   * @return {Number}\n   */\n  core.Node.prototype.compareDocumentPosition = function compareDocumentPosition (other) {\n    // Let reference be the context object.\n    var reference = this;\n\n    if(!(other instanceof core.Node)) {\n      throw Error(\"Comparing position against non-Node values is not allowed\");\n    }\n\n    if (isObsoleteNodeType(reference) || isObsoleteNodeType(other)) {\n      throw new Error(\"Obsolete node type\");\n    }\n\n    // If other and reference are the same object, return zero.\n    if(reference.isSameNode(other)) {\n      return 0;\n    }\n\n    // If other and reference are not in the same tree, return the result of adding DOCUMENT_POSITION_DISCONNECTED,\n    // DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC, and either DOCUMENT_POSITION_PRECEDING or DOCUMENT_POSITION_FOLLOWING,\n    // with the constraint that this is to be consistent, together.\n    if(findNodeRoot(reference) !== findNodeRoot(other)) {\n      return DOCUMENT_POSITION_DISCONNECTED + DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC + DOCUMENT_POSITION_FOLLOWING;\n    }\n\n    // If other is an ancestor of reference, return the result of adding DOCUMENT_POSITION_CONTAINS to\n    // DOCUMENT_POSITION_PRECEDING.\n    if(isAncestor(reference, other)) {\n      return DOCUMENT_POSITION_CONTAINS + DOCUMENT_POSITION_PRECEDING;\n    }\n\n    // If other is a descendant of reference, return the result of adding DOCUMENT_POSITION_CONTAINED_BY to\n    // DOCUMENT_POSITION_FOLLOWING.\n    if(isAncestor(other, reference)) {\n      return DOCUMENT_POSITION_CONTAINED_BY + DOCUMENT_POSITION_FOLLOWING;\n    }\n\n    // If other is preceding reference return DOCUMENT_POSITION_PRECEDING, otherwise return DOCUMENT_POSITION_FOLLOWING\n    return followingOrPreceding(findNodeRoot(reference), reference, other);\n  };\n\n  /**\n   * The contains(other) method returns true if other is an inclusive descendant of the context object,\n   * and false otherwise (including when other is null).\n   * @param  {[Node]} other [the node to test]\n   * @return {[boolean]}      [whether other is an inclusive descendant of this]\n   */\n  core.Node.prototype.contains = function (other) {\n    return other instanceof core.Node &&\n    (this.isSameNode(other) || !!(this.compareDocumentPosition(other) & DOCUMENT_POSITION_CONTAINED_BY));\n  };\n\n  // http://dom.spec.whatwg.org/#dom-node-parentelement\n  defineGetter(core.Node.prototype, \"parentElement\", function () {\n    return this._parentNode !== null && this._parentNode.nodeType === core.Node.ELEMENT_NODE ? this._parentNode : null;\n  });\n};\n"]},"metadata":{},"sourceType":"script"}