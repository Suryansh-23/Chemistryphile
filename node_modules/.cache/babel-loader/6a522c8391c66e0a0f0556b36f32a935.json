{"ast":null,"code":"/** Here is yet another implementation of XPath 1.0 in Javascript.\n *\n * My goal was to make it relatively compact, but as I fixed all the axis bugs\n * the axes became more and more complicated. :-(.\n *\n * I have not implemented namespaces or case-sensitive axes for XML yet.\n *\n * How to test it in Chrome: You can make a Chrome extension that replaces\n * the WebKit XPath parser with this one. But it takes a bit of effort to\n * get around isolated world and same-origin restrictions:\n * manifest.json:\n    {\n      \"name\": \"XPathTest\",\n      \"version\": \"0.1\",\n      \"content_scripts\": [{\n        \"matches\": [\"http://localhost/*\"],  // or wildcard host\n        \"js\": [\"xpath.js\", \"injection.js\"],\n        \"all_frames\": true, \"run_at\": \"document_start\"\n      }]\n    }\n * injection.js:\n    // goal: give my xpath object to the website's JS context.\n    var script = document.createElement('script');\n    script.textContent =\n        \"document.addEventListener('xpathextend', function(e) {\\n\" +\n        \"  console.log('extending document with xpath...');\\n\" +\n        \"  e.detail(window);\" +\n        \"});\";\n    document.documentElement.appendChild(script);\n    document.documentElement.removeChild(script);\n    var evt = document.createEvent('CustomEvent');\n    evt.initCustomEvent('xpathextend', true, true, this.xpath.extend);\n    document.dispatchEvent(evt);\n */\n(function () {\n  var xpath;\n  var core;\n\n  if ('function' === typeof require) {\n    xpath = exports; // the tests go through this\n\n    core = require(\"../level1/core\");\n  } else {\n    xpath = {};\n    core = this;\n  }\n  /***************************************************************************\n   *                            Tokenization                                 *\n   ***************************************************************************/\n\n  /**\n   * The XPath lexer is basically a single regular expression, along with\n   * some helper functions to pop different types.\n   */\n\n\n  var Stream = xpath.Stream = function Stream(str) {\n    this.original = this.str = str;\n    this.peeked = null; // TODO: not really needed, but supposedly tokenizer also disambiguates\n    // a * b vs. node test *\n\n    this.prev = null; // for debugging\n\n    this.prevprev = null;\n  };\n\n  Stream.prototype = {\n    peek: function () {\n      if (this.peeked) return this.peeked;\n      var m = this.re.exec(this.str);\n      if (!m) return null;\n      this.str = this.str.substr(m[0].length);\n      return this.peeked = m[1];\n    },\n\n    /** Peek 2 tokens ahead. */\n    peek2: function () {\n      this.peek(); // make sure this.peeked is set\n\n      var m = this.re.exec(this.str);\n      if (!m) return null;\n      return m[1];\n    },\n    pop: function () {\n      var r = this.peek();\n      this.peeked = null;\n      this.prevprev = this.prev;\n      this.prev = r;\n      return r;\n    },\n    trypop: function (tokens) {\n      var tok = this.peek();\n      if (tok === tokens) return this.pop();\n\n      if (Array.isArray(tokens)) {\n        for (var i = 0; i < tokens.length; ++i) {\n          var t = tokens[i];\n          if (t == tok) return this.pop();\n          ;\n        }\n      }\n    },\n    trypopfuncname: function () {\n      var tok = this.peek();\n      if (!this.isQnameRe.test(tok)) return null;\n\n      switch (tok) {\n        case 'comment':\n        case 'text':\n        case 'processing-instruction':\n        case 'node':\n          return null;\n      }\n\n      if ('(' != this.peek2()) return null;\n      return this.pop();\n    },\n    trypopaxisname: function () {\n      var tok = this.peek();\n\n      switch (tok) {\n        case 'ancestor':\n        case 'ancestor-or-self':\n        case 'attribute':\n        case 'child':\n        case 'descendant':\n        case 'descendant-or-self':\n        case 'following':\n        case 'following-sibling':\n        case 'namespace':\n        case 'parent':\n        case 'preceding':\n        case 'preceding-sibling':\n        case 'self':\n          if ('::' == this.peek2()) return this.pop();\n      }\n\n      return null;\n    },\n    trypopnametest: function () {\n      var tok = this.peek();\n      if ('*' === tok || this.startsWithNcNameRe.test(tok)) return this.pop();\n      return null;\n    },\n    trypopliteral: function () {\n      var tok = this.peek();\n      if (null == tok) return null;\n      var first = tok.charAt(0);\n      var last = tok.charAt(tok.length - 1);\n\n      if ('\"' === first && '\"' === last || \"'\" === first && \"'\" === last) {\n        this.pop();\n        return tok.substr(1, tok.length - 2);\n      }\n    },\n    trypopnumber: function () {\n      var tok = this.peek();\n      if (this.isNumberRe.test(tok)) return parseFloat(this.pop());else return null;\n    },\n    trypopvarref: function () {\n      var tok = this.peek();\n      if (null == tok) return null;\n      if ('$' === tok.charAt(0)) return this.pop().substr(1);else return null;\n    },\n    position: function () {\n      return this.original.length - this.str.length;\n    }\n  };\n\n  (function () {\n    // http://www.w3.org/TR/REC-xml-names/#NT-NCName\n    var nameStartCharsExceptColon = 'A-Z_a-z\\xc0-\\xd6\\xd8-\\xf6\\xF8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF' + '\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF' + '\\uFDF0-\\uFFFD'; // JS doesn't support [#x10000-#xEFFFF]\n\n    var nameCharExceptColon = nameStartCharsExceptColon + '\\\\-\\\\.0-9\\xb7\\u0300-\\u036F\\u203F-\\u2040';\n    var ncNameChars = '[' + nameStartCharsExceptColon + '][' + nameCharExceptColon + ']*'; // http://www.w3.org/TR/REC-xml-names/#NT-QName\n\n    var qNameChars = ncNameChars + '(?::' + ncNameChars + ')?';\n    var otherChars = '\\\\.\\\\.|[\\\\(\\\\)\\\\[\\\\].@,]|::'; // .. must come before [.]\n\n    var operatorChars = 'and|or|mod|div|' + '//|!=|<=|>=|[*/|+\\\\-=<>]'; // //, !=, <=, >= before individual ones.\n\n    var literal = '\"[^\"]*\"|' + \"'[^']*'\";\n    var numberChars = '[0-9]+(?:\\\\.[0-9]*)?|\\\\.[0-9]+';\n    var variableReference = '\\\\$' + qNameChars;\n    var nameTestChars = '\\\\*|' + ncNameChars + ':\\\\*|' + qNameChars;\n    var optionalSpace = '[ \\t\\r\\n]*'; // stricter than regexp \\s.\n\n    var nodeType = 'comment|text|processing-instruction|node';\n    var re = new RegExp( // numberChars before otherChars so that leading-decimal doesn't become .\n    '^' + optionalSpace + '(' + numberChars + '|' + otherChars + '|' + nameTestChars + '|' + operatorChars + '|' + literal + '|' + variableReference + ')' // operatorName | nodeType | functionName | axisName are lumped into\n    // qName for now; we'll check them on pop.\n    );\n    Stream.prototype.re = re;\n    Stream.prototype.startsWithNcNameRe = new RegExp('^' + ncNameChars);\n    Stream.prototype.isQnameRe = new RegExp('^' + qNameChars + '$');\n    Stream.prototype.isNumberRe = new RegExp('^' + numberChars + '$');\n  })();\n  /***************************************************************************\n   *                               Parsing                                   *\n   ***************************************************************************/\n\n\n  var parse = xpath.parse = function parse(stream, a) {\n    var r = orExpr(stream, a);\n    var x,\n        unparsed = [];\n\n    while (x = stream.pop()) {\n      unparsed.push(x);\n    }\n\n    if (unparsed.length) throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'Position ' + stream.position() + ': Unparsed tokens: ' + unparsed.join(' '));\n    return r;\n  };\n  /**\n   * binaryL  ::= subExpr\n   *            | binaryL op subExpr\n   * so a op b op c becomes ((a op b) op c)\n   */\n\n\n  function binaryL(subExpr, stream, a, ops) {\n    var lhs = subExpr(stream, a);\n    if (lhs == null) return null;\n    var op;\n\n    while (op = stream.trypop(ops)) {\n      var rhs = subExpr(stream, a);\n      if (rhs == null) throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'Position ' + stream.position() + ': Expected something after ' + op);\n      lhs = a.node(op, lhs, rhs);\n    }\n\n    return lhs;\n  }\n  /**\n   * Too bad this is never used. If they made a ** operator (raise to power),\n   ( we would use it.\n   * binaryR  ::= subExpr\n   *            | subExpr op binaryR\n   * so a op b op c becomes (a op (b op c))\n   */\n\n\n  function binaryR(subExpr, stream, a, ops) {\n    var lhs = subExpr(stream, a);\n    if (lhs == null) return null;\n    var op = stream.trypop(ops);\n\n    if (op) {\n      var rhs = binaryR(stream, a);\n      if (rhs == null) throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'Position ' + stream.position() + ': Expected something after ' + op);\n      return a.node(op, lhs, rhs);\n    } else {\n      return lhs; // TODO\n    }\n  }\n  /** [1] LocationPath::= RelativeLocationPath | AbsoluteLocationPath\n   * e.g. a, a/b, //a/b\n   */\n\n\n  function locationPath(stream, a) {\n    return absoluteLocationPath(stream, a) || relativeLocationPath(null, stream, a);\n  }\n  /** [2] AbsoluteLocationPath::= '/' RelativeLocationPath? | AbbreviatedAbsoluteLocationPath\n   *  [10] AbbreviatedAbsoluteLocationPath::= '//' RelativeLocationPath\n   */\n\n\n  function absoluteLocationPath(stream, a) {\n    var op = stream.peek();\n\n    if ('/' === op || '//' === op) {\n      var lhs = a.node('Root');\n      return relativeLocationPath(lhs, stream, a, true);\n    } else {\n      return null;\n    }\n  }\n  /** [3] RelativeLocationPath::= Step | RelativeLocationPath '/' Step |\n   *                            | AbbreviatedRelativeLocationPath\n   *  [11] AbbreviatedRelativeLocationPath::= RelativeLocationPath '//' Step\n   * e.g. p/a, etc.\n   */\n\n\n  function relativeLocationPath(lhs, stream, a, isOnlyRootOk) {\n    if (null == lhs) {\n      lhs = step(stream, a);\n      if (null == lhs) return lhs;\n    }\n\n    var op;\n\n    while (op = stream.trypop(['/', '//'])) {\n      if ('//' === op) {\n        lhs = a.node('/', lhs, a.node('Axis', 'descendant-or-self', 'node', undefined));\n      }\n\n      var rhs = step(stream, a);\n      if (null == rhs && '/' === op && isOnlyRootOk) return lhs;else isOnlyRootOk = false;\n      if (null == rhs) throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'Position ' + stream.position() + ': Expected step after ' + op);\n      lhs = a.node('/', lhs, rhs);\n    }\n\n    return lhs;\n  }\n  /** [4] Step::= AxisSpecifier NodeTest Predicate* | AbbreviatedStep\n   *  [12] AbbreviatedStep::= '.' | '..'\n   * e.g. @href, self::p, p, a[@href], ., ..\n   */\n\n\n  function step(stream, a) {\n    var abbrStep = stream.trypop(['.', '..']);\n    if ('.' === abbrStep) // A location step of . is short for self::node().\n      return a.node('Axis', 'self', 'node');\n    if ('..' === abbrStep) // A location step of .. is short for parent::node()\n      return a.node('Axis', 'parent', 'node');\n    var axis = axisSpecifier(stream, a);\n    var nodeType = nodeTypeTest(stream, a);\n    var nodeName;\n    if (null == nodeType) nodeName = nodeNameTest(stream, a);\n    if (null == axis && null == nodeType && null == nodeName) return null;\n    if (null == nodeType && null == nodeName) throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'Position ' + stream.position() + ': Expected nodeTest after axisSpecifier ' + axis);\n    if (null == axis) axis = 'child';\n\n    if (null == nodeType) {\n      // When there's only a node name, then the node type is forced to be the\n      // principal node type of the axis.\n      // see http://www.w3.org/TR/xpath/#dt-principal-node-type\n      if ('attribute' === axis) nodeType = 'attribute';else if ('namespace' === axis) nodeType = 'namespace';else nodeType = 'element';\n    }\n\n    var lhs = a.node('Axis', axis, nodeType, nodeName);\n    var pred;\n\n    while (null != (pred = predicate(lhs, stream, a))) {\n      lhs = pred;\n    }\n\n    return lhs;\n  }\n  /** [5] AxisSpecifier::= AxisName '::' | AbbreviatedAxisSpecifier\n   *  [6] AxisName::= 'ancestor' | 'ancestor-or-self' | 'attribute' | 'child'\n   *                | 'descendant' | 'descendant-or-self' | 'following'\n   *                | 'following-sibling' | 'namespace' | 'parent' |\n   *                | 'preceding' | 'preceding-sibling' | 'self'\n   *  [13] AbbreviatedAxisSpecifier::= '@'?\n   */\n\n\n  function axisSpecifier(stream, a) {\n    var attr = stream.trypop('@');\n    if (null != attr) return 'attribute';\n    var axisName = stream.trypopaxisname();\n\n    if (null != axisName) {\n      var coloncolon = stream.trypop('::');\n      if (null == coloncolon) throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'Position ' + stream.position() + ': Should not happen. Should be ::.');\n      return axisName;\n    }\n  }\n  /** [7] NodeTest::= NameTest | NodeType '(' ')' | 'processing-instruction' '(' Literal ')'\n   *  [38] NodeType::= 'comment' | 'text' | 'processing-instruction' | 'node'\n   * I've split nodeTypeTest from nodeNameTest for convenience.\n   */\n\n\n  function nodeTypeTest(stream, a) {\n    if ('(' !== stream.peek2()) {\n      return null;\n    }\n\n    var type = stream.trypop(['comment', 'text', 'processing-instruction', 'node']);\n\n    if (null != type) {\n      if (null == stream.trypop('(')) throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'Position ' + stream.position() + ': Should not happen.');\n      var param = undefined;\n\n      if (type == 'processing-instruction') {\n        param = stream.trypopliteral();\n      }\n\n      if (null == stream.trypop(')')) throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'Position ' + stream.position() + ': Expected close parens.');\n      return type;\n    }\n  }\n\n  function nodeNameTest(stream, a) {\n    var name = stream.trypopnametest();\n    if (name != null) return name;else return null;\n  }\n  /** [8] Predicate::= '[' PredicateExpr ']'\n   *  [9] PredicateExpr::= Expr\n   */\n\n\n  function predicate(lhs, stream, a) {\n    if (null == stream.trypop('[')) return null;\n    var expr = orExpr(stream, a);\n    if (null == expr) throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'Position ' + stream.position() + ': Expected expression after [');\n    if (null == stream.trypop(']')) throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'Position ' + stream.position() + ': Expected ] after expression.');\n    return a.node('Predicate', lhs, expr);\n  }\n  /** [14] Expr::= OrExpr\n   */\n\n  /** [15] PrimaryExpr::= VariableReference | '(' Expr ')' | Literal | Number | FunctionCall\n   * e.g. $x,  (3+4),  \"hi\",  32,  f(x)\n   */\n\n\n  function primaryExpr(stream, a) {\n    var x = stream.trypopliteral();\n    if (null == x) x = stream.trypopnumber();\n\n    if (null != x) {\n      return x;\n    }\n\n    var varRef = stream.trypopvarref();\n    if (null != varRef) return a.node('VariableReference', varRef);\n    var funCall = functionCall(stream, a);\n\n    if (null != funCall) {\n      return funCall;\n    }\n\n    if (stream.trypop('(')) {\n      var e = orExpr(stream, a);\n      if (null == e) throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'Position ' + stream.position() + ': Expected expression after (.');\n      if (null == stream.trypop(')')) throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'Position ' + stream.position() + ': Expected ) after expression.');\n      return e;\n    }\n\n    return null;\n  }\n  /** [16] FunctionCall::= FunctionName '(' ( Argument ( ',' Argument )* )? ')'\n   *  [17] Argument::= Expr\n   */\n\n\n  function functionCall(stream, a) {\n    var name = stream.trypopfuncname(stream, a);\n    if (null == name) return null;\n    if (null == stream.trypop('(')) throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'Position ' + stream.position() + ': Expected ( ) after function name.');\n    var params = [];\n    var first = true;\n\n    while (null == stream.trypop(')')) {\n      if (!first && null == stream.trypop(',')) throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'Position ' + stream.position() + ': Expected , between arguments of the function.');\n      first = false;\n      var param = orExpr(stream, a);\n      if (param == null) throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'Position ' + stream.position() + ': Expected expression as argument of function.');\n      params.push(param);\n    }\n\n    return a.node('FunctionCall', name, params);\n  }\n  /** [18] UnionExpr::= PathExpr | UnionExpr '|' PathExpr\n   */\n\n\n  function unionExpr(stream, a) {\n    return binaryL(pathExpr, stream, a, '|');\n  }\n  /** [19] PathExpr ::= LocationPath\n   *                  | FilterExpr\n   *                  | FilterExpr '/' RelativeLocationPath\n   *                  | FilterExpr '//' RelativeLocationPath\n   * Unlike most other nodes, this one always generates a node because\n   * at this point all reverse nodesets must turn into a forward nodeset\n   */\n\n\n  function pathExpr(stream, a) {\n    // We have to do FilterExpr before LocationPath because otherwise\n    // LocationPath will eat up the name from a function call.\n    var filter = filterExpr(stream, a);\n\n    if (null == filter) {\n      var loc = locationPath(stream, a);\n\n      if (null == loc) {\n        throw new Error();\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'Position ' + stream.position() + ': The expression shouldn\\'t be empty...');\n      }\n\n      return a.node('PathExpr', loc);\n    }\n\n    var rel = relativeLocationPath(filter, stream, a, false);\n    if (filter === rel) return rel;else return a.node('PathExpr', rel);\n  }\n  /** [20] FilterExpr::= PrimaryExpr | FilterExpr Predicate\n   * aka. FilterExpr ::= PrimaryExpr Predicate*\n   */\n\n\n  function filterExpr(stream, a) {\n    var primary = primaryExpr(stream, a);\n    if (primary == null) return null;\n    var pred,\n        lhs = primary;\n\n    while (null != (pred = predicate(lhs, stream, a))) {\n      lhs = pred;\n    }\n\n    return lhs;\n  }\n  /** [21] OrExpr::= AndExpr | OrExpr 'or' AndExpr\n   */\n\n\n  function orExpr(stream, a) {\n    var orig = (stream.peeked || '') + stream.str;\n    var r = binaryL(andExpr, stream, a, 'or');\n    var now = (stream.peeked || '') + stream.str;\n    return r;\n  }\n  /** [22] AndExpr::= EqualityExpr | AndExpr 'and' EqualityExpr\n   */\n\n\n  function andExpr(stream, a) {\n    return binaryL(equalityExpr, stream, a, 'and');\n  }\n  /** [23] EqualityExpr::= RelationalExpr | EqualityExpr '=' RelationalExpr\n   *                     | EqualityExpr '!=' RelationalExpr\n   */\n\n\n  function equalityExpr(stream, a) {\n    return binaryL(relationalExpr, stream, a, ['=', '!=']);\n  }\n  /** [24] RelationalExpr::= AdditiveExpr | RelationalExpr '<' AdditiveExpr\n   *                       | RelationalExpr '>' AdditiveExpr\n   *                       | RelationalExpr '<=' AdditiveExpr\n   *                       | RelationalExpr '>=' AdditiveExpr\n   */\n\n\n  function relationalExpr(stream, a) {\n    return binaryL(additiveExpr, stream, a, ['<', '>', '<=', '>=']);\n  }\n  /** [25] AdditiveExpr::= MultiplicativeExpr\n   *                     | AdditiveExpr '+' MultiplicativeExpr\n   *                     | AdditiveExpr '-' MultiplicativeExpr\n   */\n\n\n  function additiveExpr(stream, a) {\n    return binaryL(multiplicativeExpr, stream, a, ['+', '-']);\n  }\n  /** [26] MultiplicativeExpr::= UnaryExpr\n   *                           | MultiplicativeExpr MultiplyOperator UnaryExpr\n   *                           | MultiplicativeExpr 'div' UnaryExpr\n   *                           | MultiplicativeExpr 'mod' UnaryExpr\n   */\n\n\n  function multiplicativeExpr(stream, a) {\n    return binaryL(unaryExpr, stream, a, ['*', 'div', 'mod']);\n  }\n  /** [27] UnaryExpr::= UnionExpr | '-' UnaryExpr\n   */\n\n\n  function unaryExpr(stream, a) {\n    if (stream.trypop('-')) {\n      var e = unaryExpr(stream, a);\n      if (null == e) throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'Position ' + stream.position() + ': Expected unary expression after -');\n      return a.node('UnaryMinus', e);\n    } else return unionExpr(stream, a);\n  }\n\n  var astFactory = {\n    node: function () {\n      return Array.prototype.slice.call(arguments);\n    }\n  };\n  /***************************************************************************\n   *                            Optimizations (TODO)                         *\n   ***************************************************************************/\n\n  /**\n   * Some things I've been considering:\n   * 1) a//b becomes a/descendant::b if there's no predicate that uses\n   *    position() or last()\n   * 2) axis[pred]: when pred doesn't use position, evaluate it just once per\n   *    node in the node-set rather than once per (node, position, last).\n   * For more optimizations, look up Gecko's optimizer:\n   * http://mxr.mozilla.org/mozilla-central/source/content/xslt/src/xpath/txXPathOptimizer.cpp\n   */\n  // TODO\n\n  function optimize(ast) {}\n  /***************************************************************************\n   *                           Evaluation: axes                              *\n   ***************************************************************************/\n\n  /**\n   * Data types: For string, number, boolean, we just use Javascript types.\n   * Node-sets have the form\n   *    {nodes: [node, ...]}\n   * or {nodes: [node, ...], pos: [[1], [2], ...], lasts: [[1], [2], ...]}\n   *\n   * Most of the time, only the node is used and the position information is\n   * discarded. But if you use a predicate, we need to try every value of\n   * position and last in case the predicate calls position() or last().\n   */\n\n  /**\n   * The NodeMultiSet is a helper class to help generate\n   * {nodes:[], pos:[], lasts:[]} structures. It is useful for the\n   * descendant, descendant-or-self, following-sibling, and\n   * preceding-sibling axes for which we can use a stack to organize things.\n   */\n\n\n  function NodeMultiSet(isReverseAxis) {\n    this.nodes = [];\n    this.pos = [];\n    this.lasts = [];\n    this.nextPos = [];\n    this.seriesIndexes = []; // index within nodes that each series begins.\n\n    this.isReverseAxis = isReverseAxis;\n    this._pushToNodes = isReverseAxis ? Array.prototype.unshift : Array.prototype.push;\n  }\n\n  NodeMultiSet.prototype = {\n    pushSeries: function pushSeries() {\n      this.nextPos.push(1);\n      this.seriesIndexes.push(this.nodes.length);\n    },\n    popSeries: function popSeries() {\n      console.assert(0 < this.nextPos.length, this.nextPos);\n      var last = this.nextPos.pop() - 1,\n          indexInPos = this.nextPos.length,\n          seriesBeginIndex = this.seriesIndexes.pop(),\n          seriesEndIndex = this.nodes.length;\n\n      for (var i = seriesBeginIndex; i < seriesEndIndex; ++i) {\n        console.assert(indexInPos < this.lasts[i].length);\n        console.assert(undefined === this.lasts[i][indexInPos]);\n        this.lasts[i][indexInPos] = last;\n      }\n    },\n    finalize: function () {\n      if (null == this.nextPos) return this;\n      console.assert(0 === this.nextPos.length);\n\n      for (var i = 0; i < this.lasts.length; ++i) {\n        for (var j = 0; j < this.lasts[i].length; ++j) {\n          console.assert(null != this.lasts[i][j], i + ',' + j + ':' + JSON.stringify(this.lasts));\n        }\n      }\n\n      this.pushSeries = this.popSeries = this.addNode = function () {\n        throw new Error('Already finalized.');\n      };\n\n      return this;\n    },\n    addNode: function addNode(node) {\n      console.assert(node);\n\n      this._pushToNodes.call(this.nodes, node);\n\n      this._pushToNodes.call(this.pos, this.nextPos.slice());\n\n      this._pushToNodes.call(this.lasts, new Array(this.nextPos.length));\n\n      for (var i = 0; i < this.nextPos.length; ++i) this.nextPos[i]++;\n    },\n    simplify: function () {\n      this.finalize();\n      return {\n        nodes: this.nodes,\n        pos: this.pos,\n        lasts: this.lasts\n      };\n    }\n  };\n\n  function eachContext(nodeMultiSet) {\n    var r = [];\n\n    for (var i = 0; i < nodeMultiSet.nodes.length; i++) {\n      var node = nodeMultiSet.nodes[i];\n\n      if (!nodeMultiSet.pos) {\n        r.push({\n          nodes: [node],\n          pos: [[i + 1]],\n          lasts: [[nodeMultiSet.nodes.length]]\n        });\n      } else {\n        for (var j = 0; j < nodeMultiSet.pos[i].length; ++j) {\n          r.push({\n            nodes: [node],\n            pos: [[nodeMultiSet.pos[i][j]]],\n            lasts: [[nodeMultiSet.lasts[i][j]]]\n          });\n        }\n      }\n    }\n\n    return r;\n  }\n  /** Matcher used in the axes.\n   */\n\n\n  function NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase) {\n    this.nodeTypeNum = nodeTypeNum;\n    this.nodeName = nodeName;\n    this.shouldLowerCase = shouldLowerCase;\n    this.nodeNameTest = null == nodeName ? this._alwaysTrue : shouldLowerCase ? this._nodeNameLowerCaseEquals : this._nodeNameEquals;\n  }\n\n  NodeMatcher.prototype = {\n    matches: function matches(node) {\n      return (0 === this.nodeTypeNum || node.nodeType === this.nodeTypeNum) && this.nodeNameTest(node.nodeName);\n    },\n    _alwaysTrue: function (name) {\n      return true;\n    },\n    _nodeNameEquals: function _nodeNameEquals(name) {\n      return this.nodeName === name;\n    },\n    _nodeNameLowerCaseEquals: function _nodeNameLowerCaseEquals(name) {\n      return this.nodeName === name.toLowerCase();\n    }\n  };\n\n  function followingSiblingHelper(nodeList\n  /*destructive!*/\n  , nodeTypeNum, nodeName, shouldLowerCase, shift, peek, followingNode, andSelf, isReverseAxis) {\n    var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n    var nodeMultiSet = new NodeMultiSet(isReverseAxis);\n\n    while (0 < nodeList.length) {\n      // can be if for following, preceding\n      var node = shift.call(nodeList);\n      console.assert(node != null);\n      node = followingNode(node);\n      nodeMultiSet.pushSeries();\n      var numPushed = 1;\n\n      while (null != node) {\n        if (!andSelf && matcher.matches(node)) nodeMultiSet.addNode(node);\n\n        if (node === peek.call(nodeList)) {\n          shift.call(nodeList);\n          nodeMultiSet.pushSeries();\n          numPushed++;\n        }\n\n        if (andSelf && matcher.matches(node)) nodeMultiSet.addNode(node);\n        node = followingNode(node);\n      }\n\n      while (0 < numPushed--) nodeMultiSet.popSeries();\n    }\n\n    return nodeMultiSet;\n  }\n  /** Returns the next non-descendant node in document order.\n   * This is the first node in following::node(), if node is the context.\n   */\n\n\n  function followingNonDescendantNode(node) {\n    if (node.ownerElement) {\n      if (node.ownerElement.firstChild) return node.ownerElement.firstChild;\n      node = node.ownerElement;\n    }\n\n    do {\n      if (node.nextSibling) return node.nextSibling;\n    } while (node = node.parentNode);\n\n    return null;\n  }\n  /** Returns the next node in a document-order depth-first search.\n   * See the definition of document order[1]:\n   *   1) element\n   *   2) namespace nodes\n   *   3) attributes\n   *   4) children\n   *   [1]: http://www.w3.org/TR/xpath/#dt-document-order\n   */\n\n\n  function followingNode(node) {\n    if (node.ownerElement) // attributes: following node of element.\n      node = node.ownerElement;\n    if (null != node.firstChild) return node.firstChild;\n\n    do {\n      if (null != node.nextSibling) {\n        return node.nextSibling;\n      }\n\n      node = node.parentNode;\n    } while (node);\n\n    return null;\n  }\n  /** Returns the previous node in document order (excluding attributes\n   * and namespace nodes).\n   */\n\n\n  function precedingNode(node) {\n    if (node.ownerElement) return node.ownerElement;\n\n    if (null != node.previousSibling) {\n      node = node.previousSibling;\n\n      while (null != node.lastChild) {\n        node = node.lastChild;\n      }\n\n      return node;\n    }\n\n    if (null != node.parentNode) {\n      return node.parentNode;\n    }\n\n    return null;\n  }\n  /** This axis is inefficient if there are many nodes in the nodeList.\n   * But I think it's a pretty useless axis so it's ok. */\n\n\n  function followingHelper(nodeList\n  /*destructive!*/\n  , nodeTypeNum, nodeName, shouldLowerCase) {\n    var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n    var nodeMultiSet = new NodeMultiSet(false);\n    var cursor = nodeList[0];\n    var unorderedFollowingStarts = [];\n\n    for (var i = 0; i < nodeList.length; i++) {\n      var node = nodeList[i];\n      var start = followingNonDescendantNode(node);\n      if (start) unorderedFollowingStarts.push(start);\n    }\n\n    if (0 === unorderedFollowingStarts.length) return {\n      nodes: []\n    };\n    var pos = [],\n        nextPos = [];\n    var started = 0;\n\n    while (cursor = followingNode(cursor)) {\n      for (var i = unorderedFollowingStarts.length - 1; i >= 0; i--) {\n        if (cursor === unorderedFollowingStarts[i]) {\n          nodeMultiSet.pushSeries();\n          unorderedFollowingStarts.splice(i, i + 1);\n          started++;\n        }\n      }\n\n      if (started && matcher.matches(cursor)) {\n        nodeMultiSet.addNode(cursor);\n      }\n    }\n\n    console.assert(0 === unorderedFollowingStarts.length);\n\n    for (var i = 0; i < started; i++) nodeMultiSet.popSeries();\n\n    return nodeMultiSet.finalize();\n  }\n\n  function precedingHelper(nodeList\n  /*destructive!*/\n  , nodeTypeNum, nodeName, shouldLowerCase) {\n    var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n    var cursor = nodeList.pop();\n    if (null == cursor) return {\n      nodes: {}\n    };\n    var r = {\n      nodes: [],\n      pos: [],\n      lasts: []\n    };\n    var nextParents = [cursor.parentNode || cursor.ownerElement],\n        nextPos = [1];\n\n    while (cursor = precedingNode(cursor)) {\n      if (cursor === nodeList[nodeList.length - 1]) {\n        nextParents.push(nodeList.pop());\n        nextPos.push(1);\n      }\n\n      var matches = matcher.matches(cursor);\n      var pos,\n          someoneUsed = false;\n      if (matches) pos = nextPos.slice();\n\n      for (var i = 0; i < nextParents.length; ++i) {\n        if (cursor === nextParents[i]) {\n          nextParents[i] = cursor.parentNode || cursor.ownerElement;\n\n          if (matches) {\n            pos[i] = null;\n          }\n        } else {\n          if (matches) {\n            pos[i] = nextPos[i]++;\n            someoneUsed = true;\n          }\n        }\n      }\n\n      if (someoneUsed) {\n        r.nodes.unshift(cursor);\n        r.pos.unshift(pos);\n      }\n    }\n\n    for (var i = 0; i < r.pos.length; ++i) {\n      var lasts = [];\n      r.lasts.push(lasts);\n\n      for (var j = r.pos[i].length - 1; j >= 0; j--) {\n        if (null == r.pos[i][j]) {\n          r.pos[i].splice(j, j + 1);\n        } else {\n          lasts.unshift(nextPos[j] - 1);\n        }\n      }\n    }\n\n    return r;\n  }\n  /** node-set, axis -> node-set */\n\n\n  function descendantDfs(nodeMultiSet, node, remaining, matcher, andSelf, attrIndices, attrNodes) {\n    while (0 < remaining.length && null != remaining[0].ownerElement) {\n      var attr = remaining.shift();\n\n      if (andSelf && matcher.matches(attr)) {\n        attrNodes.push(attr);\n        attrIndices.push(nodeMultiSet.nodes.length);\n      }\n    }\n\n    if (null != node && !andSelf) {\n      if (matcher.matches(node)) nodeMultiSet.addNode(node);\n    }\n\n    var pushed = false;\n\n    if (null == node) {\n      if (0 === remaining.length) return;\n      node = remaining.shift();\n      nodeMultiSet.pushSeries();\n      pushed = true;\n    } else if (0 < remaining.length && node === remaining[0]) {\n      nodeMultiSet.pushSeries();\n      pushed = true;\n      remaining.shift();\n    }\n\n    if (andSelf) {\n      if (matcher.matches(node)) nodeMultiSet.addNode(node);\n    } // TODO: use optimization. Also try element.getElementsByTagName\n    // var nodeList = 1 === nodeTypeNum && null != node.children ? node.children : node.childNodes;\n\n\n    var nodeList = node.childNodes;\n\n    for (var j = 0; j < nodeList.length; ++j) {\n      var child = nodeList[j];\n      descendantDfs(nodeMultiSet, child, remaining, matcher, andSelf, attrIndices, attrNodes);\n    }\n\n    if (pushed) {\n      nodeMultiSet.popSeries();\n    }\n  }\n\n  function descenantHelper(nodeList\n  /*destructive!*/\n  , nodeTypeNum, nodeName, shouldLowerCase, andSelf) {\n    var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n    var nodeMultiSet = new NodeMultiSet(false);\n    var attrIndices = [],\n        attrNodes = [];\n\n    while (0 < nodeList.length) {\n      // var node = nodeList.shift();\n      descendantDfs(nodeMultiSet, null, nodeList, matcher, andSelf, attrIndices, attrNodes);\n    }\n\n    nodeMultiSet.finalize();\n\n    for (var i = attrNodes.length - 1; i >= 0; --i) {\n      nodeMultiSet.nodes.splice(attrIndices[i], attrIndices[i], attrNodes[i]);\n      nodeMultiSet.pos.splice(attrIndices[i], attrIndices[i], [1]);\n      nodeMultiSet.lasts.splice(attrIndices[i], attrIndices[i], [1]);\n    }\n\n    return nodeMultiSet;\n  }\n  /**\n   */\n\n\n  function ancestorHelper(nodeList\n  /*destructive!*/\n  , nodeTypeNum, nodeName, shouldLowerCase, andSelf) {\n    var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n    var ancestors = []; // array of non-empty arrays of matching ancestors\n\n    for (var i = 0; i < nodeList.length; ++i) {\n      var node = nodeList[i];\n      var isFirst = true;\n      var a = [];\n\n      while (null != node) {\n        if (!isFirst || andSelf) {\n          if (matcher.matches(node)) a.push(node);\n        }\n\n        isFirst = false;\n        node = node.parentNode || node.ownerElement;\n      }\n\n      if (0 < a.length) ancestors.push(a);\n    }\n\n    var lasts = [];\n\n    for (var i = 0; i < ancestors.length; ++i) lasts.push(ancestors[i].length);\n\n    var nodeMultiSet = new NodeMultiSet(true);\n    var newCtx = {\n      nodes: [],\n      pos: [],\n      lasts: []\n    };\n\n    while (0 < ancestors.length) {\n      var pos = [ancestors[0].length];\n      var last = [lasts[0]];\n      var node = ancestors[0].pop();\n\n      for (var i = ancestors.length - 1; i > 0; --i) {\n        if (node === ancestors[i][ancestors[i].length - 1]) {\n          pos.push(ancestors[i].length);\n          last.push(lasts[i]);\n          ancestors[i].pop();\n\n          if (0 === ancestors[i].length) {\n            ancestors.splice(i, i + 1);\n            lasts.splice(i, i + 1);\n          }\n        }\n      }\n\n      if (0 === ancestors[0].length) {\n        ancestors.shift();\n        lasts.shift();\n      }\n\n      newCtx.nodes.push(node);\n      newCtx.pos.push(pos);\n      newCtx.lasts.push(last);\n    }\n\n    return newCtx;\n  }\n  /** Helper function for sortDocumentOrder. Returns a list of indices, from the\n   * node to the root, of positions within parent.\n   * For convenience, the node is the first element of the array.\n   */\n\n\n  function addressVector(node) {\n    var r = [node];\n\n    if (null != node.ownerElement) {\n      node = node.ownerElement;\n      r.push(-1);\n    }\n\n    while (null != node) {\n      var i = 0;\n\n      while (null != node.previousSibling) {\n        node = node.previousSibling;\n        i++;\n      }\n\n      r.push(i);\n      node = node.parentNode;\n    }\n\n    return r;\n  }\n\n  function addressComparator(a, b) {\n    var minlen = Math.min(a.length - 1, b.length - 1),\n        // not including [0]=node\n    alen = a.length,\n        blen = b.length;\n    if (a[0] === b[0]) return 0;\n    var c;\n\n    for (var i = 0; i < minlen; ++i) {\n      c = a[alen - i - 1] - b[blen - i - 1];\n      if (0 !== c) break;\n    }\n\n    if (null == c || 0 === c) {\n      // All equal until one of the nodes. The longer one is the descendant.\n      c = alen - blen;\n    }\n\n    if (0 === c) c = a.nodeName - b.nodeName;\n    if (0 === c) c = 1;\n    return c;\n  }\n\n  var sortUniqDocumentOrder = xpath.sortUniqDocumentOrder = function (nodes) {\n    var a = [];\n\n    for (var i = 0; i < nodes.length; i++) {\n      var node = nodes[i];\n      var v = addressVector(node);\n      a.push(v);\n    }\n\n    a.sort(addressComparator);\n    var b = [];\n\n    for (var i = 0; i < a.length; i++) {\n      if (0 < i && a[i][0] === a[i - 1][0]) continue;\n      b.push(a[i][0]);\n    }\n\n    return b;\n  };\n  /** Sort node multiset. Does not do any de-duping. */\n\n\n  function sortNodeMultiSet(nodeMultiSet) {\n    var a = [];\n\n    for (var i = 0; i < nodeMultiSet.nodes.length; i++) {\n      var v = addressVector(nodeMultiSet.nodes[i]);\n      a.push({\n        v: v,\n        n: nodeMultiSet.nodes[i],\n        p: nodeMultiSet.pos[i],\n        l: nodeMultiSet.lasts[i]\n      });\n    }\n\n    a.sort(compare);\n    var r = {\n      nodes: [],\n      pos: [],\n      lasts: []\n    };\n\n    for (var i = 0; i < a.length; ++i) {\n      r.nodes.push(a[i].n);\n      r.pos.push(a[i].p);\n      r.lasts.push(a[i].l);\n    }\n\n    function compare(x, y) {\n      return addressComparator(x.v, y.v);\n    }\n\n    return r;\n  }\n  /** Returns an array containing all the ancestors down to a node.\n   * The array starts with document.\n   */\n\n\n  function nodeAndAncestors(node) {\n    var ancestors = [node];\n    var p = node;\n\n    while (p = p.parentNode || p.ownerElement) {\n      ancestors.unshift(p);\n    }\n\n    return ancestors;\n  }\n\n  function compareSiblings(a, b) {\n    if (a === b) return 0;\n    var c = a;\n\n    while (c = c.previousSibling) {\n      if (c === b) return 1; // b < a\n    }\n\n    c = b;\n\n    while (c = c.previousSibling) {\n      if (c === a) return -1; // a < b\n    }\n\n    throw new Error('a and b are not siblings: ' + xpath.stringifyObject(a) + ' vs ' + xpath.stringifyObject(b));\n  }\n  /** The merge in merge-sort.*/\n\n\n  function mergeNodeLists(x, y) {\n    var a,\n        b,\n        aanc,\n        banc,\n        r = [];\n    if ('object' !== typeof x) throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'Invalid LHS for | operator ' + '(expected node-set): ' + x);\n    if ('object' !== typeof y) throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'Invalid LHS for | operator ' + '(expected node-set): ' + y);\n\n    while (true) {\n      if (null == a) {\n        a = x.shift();\n        if (null != a) aanc = addressVector(a);\n      }\n\n      if (null == b) {\n        b = y.shift();\n        if (null != b) banc = addressVector(b);\n      }\n\n      if (null == a || null == b) break;\n      var c = addressComparator(aanc, banc);\n\n      if (c < 0) {\n        r.push(a);\n        a = null;\n        aanc = null;\n      } else if (c > 0) {\n        r.push(b);\n        b = null;\n        banc = null;\n      } else if (a.nodeName < b.nodeName) {\n        // attributes\n        r.push(a);\n        a = null;\n        aanc = null;\n      } else if (a.nodeName > b.nodeName) {\n        // attributes\n        r.push(b);\n        b = null;\n        banc = null;\n      } else if (a !== b) {\n        // choose b arbitrarily\n        r.push(b);\n        b = null;\n        banc = null;\n      } else {\n        console.assert(a === b, c); // just skip b without pushing it.\n\n        b = null;\n        banc = null;\n      }\n    }\n\n    while (a) {\n      r.push(a);\n      a = x.shift();\n    }\n\n    while (b) {\n      r.push(b);\n      b = y.shift();\n    }\n\n    return r;\n  }\n\n  function comparisonHelper(test, x, y, isNumericComparison) {\n    var coersion;\n    if (isNumericComparison) coersion = fn.number;else coersion = 'boolean' === typeof x || 'boolean' === typeof y ? fn['boolean'] : 'number' === typeof x || 'number' === typeof y ? fn.number : fn.string;\n\n    if ('object' === typeof x && 'object' === typeof y) {\n      var aMap = {};\n\n      for (var i = 0; i < x.nodes.length; ++i) {\n        var xi = coersion({\n          nodes: [x.nodes[i]]\n        });\n\n        for (var j = 0; j < y.nodes.length; ++j) {\n          var yj = coersion({\n            nodes: [y.nodes[j]]\n          });\n          if (test(xi, yj)) return true;\n        }\n      }\n\n      return false;\n    } else if ('object' === typeof x && x.nodes && x.nodes.length) {\n      for (var i = 0; i < x.nodes.length; ++i) {\n        var xi = coersion({\n          nodes: [x.nodes[i]]\n        }),\n            yc = coersion(y);\n        if (test(xi, yc)) return true;\n      }\n\n      return false;\n    } else if ('object' === typeof y && x.nodes && x.nodes.length) {\n      for (var i = 0; i < x.nodes.length; ++i) {\n        var yi = coersion({\n          nodes: [y.nodes[i]]\n        }),\n            xc = coersion(x);\n        if (test(xc, yi)) return true;\n      }\n\n      return false;\n    } else {\n      var xc = coersion(x),\n          yc = coersion(y);\n      return test(xc, yc);\n    }\n  }\n\n  var axes = xpath.axes = {\n    'ancestor': function ancestor(nodeList\n    /*destructive!*/\n    , nodeTypeNum, nodeName, shouldLowerCase) {\n      return ancestorHelper(nodeList\n      /*destructive!*/\n      , nodeTypeNum, nodeName, shouldLowerCase, false);\n    },\n    'ancestor-or-self': function ancestorOrSelf(nodeList\n    /*destructive!*/\n    , nodeTypeNum, nodeName, shouldLowerCase) {\n      return ancestorHelper(nodeList\n      /*destructive!*/\n      , nodeTypeNum, nodeName, shouldLowerCase, true);\n    },\n    'attribute': function attribute(nodeList\n    /*destructive!*/\n    , nodeTypeNum, nodeName, shouldLowerCase) {\n      // TODO: figure out whether positions should be undefined here.\n      var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n      var nodeMultiSet = new NodeMultiSet(false);\n\n      if (null != nodeName) {\n        // TODO: with namespace\n        for (var i = 0; i < nodeList.length; ++i) {\n          var node = nodeList[i];\n          if (null == node.getAttributeNode) continue; // only Element has .getAttributeNode\n\n          var attr = node.getAttributeNode(nodeName);\n\n          if (null != attr && matcher.matches(attr)) {\n            nodeMultiSet.pushSeries();\n            nodeMultiSet.addNode(attr);\n            nodeMultiSet.popSeries();\n          }\n        }\n      } else {\n        for (var i = 0; i < nodeList.length; ++i) {\n          var node = nodeList[i];\n\n          if (null != node.attributes) {\n            nodeMultiSet.pushSeries();\n\n            for (var j = 0; j < node.attributes.length; j++) {\n              // all nodes have .attributes\n              var attr = node.attributes[j];\n              if (matcher.matches(attr)) // TODO: I think this check is unnecessary\n                nodeMultiSet.addNode(attr);\n            }\n\n            nodeMultiSet.popSeries();\n          }\n        }\n      }\n\n      return nodeMultiSet.finalize();\n    },\n    'child': function child(nodeList\n    /*destructive!*/\n    , nodeTypeNum, nodeName, shouldLowerCase) {\n      var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n      var nodeMultiSet = new NodeMultiSet(false);\n\n      for (var i = 0; i < nodeList.length; ++i) {\n        var n = nodeList[i];\n        if (n.ownerElement) // skip attribute nodes' text child.\n          continue;\n\n        if (n.childNodes) {\n          nodeMultiSet.pushSeries();\n          var childList = 1 === nodeTypeNum && null != n.children ? n.children : n.childNodes;\n\n          for (var j = 0; j < childList.length; ++j) {\n            var child = childList[j];\n\n            if (matcher.matches(child)) {\n              nodeMultiSet.addNode(child);\n            } // don't have to do de-duping because children have parent,\n            // which are current context.\n\n          }\n\n          nodeMultiSet.popSeries();\n        }\n      }\n\n      nodeMultiSet.finalize();\n      return sortNodeMultiSet(nodeMultiSet);\n    },\n    'descendant': function descenant(nodeList\n    /*destructive!*/\n    , nodeTypeNum, nodeName, shouldLowerCase) {\n      return descenantHelper(nodeList\n      /*destructive!*/\n      , nodeTypeNum, nodeName, shouldLowerCase, false);\n    },\n    'descendant-or-self': function descenantOrSelf(nodeList\n    /*destructive!*/\n    , nodeTypeNum, nodeName, shouldLowerCase) {\n      return descenantHelper(nodeList\n      /*destructive!*/\n      , nodeTypeNum, nodeName, shouldLowerCase, true);\n    },\n    'following': function following(nodeList\n    /*destructive!*/\n    , nodeTypeNum, nodeName, shouldLowerCase) {\n      return followingHelper(nodeList\n      /*destructive!*/\n      , nodeTypeNum, nodeName, shouldLowerCase);\n    },\n    'following-sibling': function followingSibling(nodeList\n    /*destructive!*/\n    , nodeTypeNum, nodeName, shouldLowerCase) {\n      return followingSiblingHelper(nodeList\n      /*destructive!*/\n      , nodeTypeNum, nodeName, shouldLowerCase, Array.prototype.shift, function () {\n        return this[0];\n      }, function (node) {\n        return node.nextSibling;\n      });\n    },\n    'namespace': function namespace(nodeList\n    /*destructive!*/\n    , nodeTypeNum, nodeName, shouldLowerCase) {// TODO\n    },\n    'parent': function parent(nodeList\n    /*destructive!*/\n    , nodeTypeNum, nodeName, shouldLowerCase) {\n      var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n      var nodes = [],\n          pos = [];\n\n      for (var i = 0; i < nodeList.length; ++i) {\n        var parent = nodeList[i].parentNode || nodeList[i].ownerElement;\n        if (null == parent) continue;\n        if (!matcher.matches(parent)) continue;\n        if (nodes.length > 0 && parent === nodes[nodes.length - 1]) continue;\n        nodes.push(parent);\n        pos.push([1]);\n      }\n\n      return {\n        nodes: nodes,\n        pos: pos,\n        lasts: pos\n      };\n    },\n    'preceding': function preceding(nodeList\n    /*destructive!*/\n    , nodeTypeNum, nodeName, shouldLowerCase) {\n      return precedingHelper(nodeList\n      /*destructive!*/\n      , nodeTypeNum, nodeName, shouldLowerCase);\n    },\n    'preceding-sibling': function precedingSibling(nodeList\n    /*destructive!*/\n    , nodeTypeNum, nodeName, shouldLowerCase) {\n      return followingSiblingHelper(nodeList\n      /*destructive!*/\n      , nodeTypeNum, nodeName, shouldLowerCase, Array.prototype.pop, function () {\n        return this[this.length - 1];\n      }, function (node) {\n        return node.previousSibling;\n      }, false, true);\n    },\n    'self': function self(nodeList\n    /*destructive!*/\n    , nodeTypeNum, nodeName, shouldLowerCase) {\n      var nodes = [],\n          pos = [];\n      var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n\n      for (var i = 0; i < nodeList.length; ++i) {\n        if (matcher.matches(nodeList[i])) {\n          nodes.push(nodeList[i]);\n          pos.push([1]);\n        }\n      }\n\n      return {\n        nodes: nodes,\n        pos: pos,\n        lasts: pos\n      };\n    }\n  };\n  /***************************************************************************\n   *                         Evaluation: functions                           *\n   ***************************************************************************/\n\n  var fn = {\n    'number': function number(optObject) {\n      if ('number' === typeof optObject) return optObject;\n      if ('string' === typeof optObject) return parseFloat(optObject); // note: parseFloat(' ') -> NaN, unlike +' ' -> 0.\n\n      if ('boolean' === typeof optObject) return +optObject;\n      return fn.number(fn.string.call(this, optObject)); // for node-sets\n    },\n    'string': function string(optObject) {\n      if (null == optObject) return fn.string(this);\n      if ('string' === typeof optObject || 'boolean' === typeof optObject || 'number' === typeof optObject) return '' + optObject;\n      if (0 == optObject.nodes.length) return '';\n      if (null != optObject.nodes[0].textContent) return optObject.nodes[0].textContent;\n      return optObject.nodes[0].nodeValue;\n    },\n    'boolean': function booleanVal(x) {\n      return 'object' === typeof x ? x.nodes.length > 0 : !!x;\n    },\n    'last': function last() {\n      console.assert(Array.isArray(this.pos));\n      console.assert(Array.isArray(this.lasts));\n      console.assert(1 === this.pos.length);\n      console.assert(1 === this.lasts.length);\n      console.assert(1 === this.lasts[0].length);\n      return this.lasts[0][0];\n    },\n    'position': function position() {\n      console.assert(Array.isArray(this.pos));\n      console.assert(Array.isArray(this.lasts));\n      console.assert(1 === this.pos.length);\n      console.assert(1 === this.lasts.length);\n      console.assert(1 === this.pos[0].length);\n      return this.pos[0][0];\n    },\n    'count': function count(nodeSet) {\n      if ('object' !== typeof nodeSet) throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'Position ' + stream.position() + ': Function count(node-set) ' + 'got wrong argument type: ' + nodeSet);\n      return nodeSet.nodes.length;\n    },\n    'id': function id(object) {\n      var r = {\n        nodes: []\n      };\n      var doc = this.nodes[0].ownerDocument || this.nodes[0];\n      console.assert(doc);\n      var ids;\n\n      if ('object' === typeof object) {\n        // for node-sets, map id over each node value.\n        ids = [];\n\n        for (var i = 0; i < object.nodes.length; ++i) {\n          var idNode = object.nodes[i];\n          var idsString = fn.string({\n            nodes: [idNode]\n          });\n          var a = idsString.split(/[ \\t\\r\\n]+/g);\n          Array.prototype.push.apply(ids, a);\n        }\n      } else {\n        var idsString = fn.string(object);\n        var a = idsString.split(/[ \\t\\r\\n]+/g);\n        ids = a;\n      }\n\n      for (var i = 0; i < ids.length; ++i) {\n        var id = ids[i];\n        if (0 === id.length) continue;\n        var node = doc.getElementById(id);\n        if (null != node) r.nodes.push(node);\n      }\n\n      r.nodes = sortUniqDocumentOrder(r.nodes);\n      return r;\n    },\n    'local-name': function (nodeSet) {\n      if (null == nodeSet) return fn.name(this);\n\n      if (null == nodeSet.nodes) {\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'argument to name() must be a node-set. got ' + nodeSet);\n      } // TODO: namespaced version\n\n\n      return nodeSet.nodes[0].nodeName.toLowerCase(); // TODO: no toLowerCase for xml\n    },\n    'namespace-uri': function (nodeSet) {\n      // TODO\n      throw new Error('not implemented yet');\n    },\n    'name': function (nodeSet) {\n      if (null == nodeSet) return fn.name(this);\n\n      if (null == nodeSet.nodes) {\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'argument to name() must be a node-set. got ' + nodeSet);\n      }\n\n      return nodeSet.nodes[0].nodeName.toLowerCase(); // TODO: no toLowerCase for xml\n    },\n    'concat': function concat(x) {\n      var l = [];\n\n      for (var i = 0; i < arguments.length; ++i) {\n        l.push(fn.string(arguments[i]));\n      }\n\n      return l.join('');\n    },\n    'starts-with': function startsWith(a, b) {\n      var as = fn.string(a),\n          bs = fn.string(b);\n      return as.substr(0, bs.length) === bs;\n    },\n    'contains': function contains(a, b) {\n      var as = fn.string(a),\n          bs = fn.string(b);\n      var i = as.indexOf(bs);\n      if (-1 === i) return false;\n      return true;\n    },\n    'substring-before': function substringBefore(a, b) {\n      var as = fn.string(a),\n          bs = fn.string(b);\n      var i = as.indexOf(bs);\n      if (-1 === i) return '';\n      return as.substr(0, i);\n    },\n    'substring-after': function substringBefore(a, b) {\n      var as = fn.string(a),\n          bs = fn.string(b);\n      var i = as.indexOf(bs);\n      if (-1 === i) return '';\n      return as.substr(i + bs.length);\n    },\n    'substring': function substring(string, start, optEnd) {\n      if (null == string || null == start) {\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'Must be at least 2 arguments to string()');\n      }\n\n      var sString = fn.string(string),\n          iStart = fn.round(start),\n          iEnd = optEnd == null ? null : fn.round(optEnd); // Note that xpath string positions user 1-based index\n\n      if (iEnd == null) return sString.substr(iStart - 1);else return sString.substr(iStart - 1, iEnd);\n    },\n    'string-length': function stringLength(optString) {\n      return fn.string.call(this, optString).length;\n    },\n    'normalize-space': function normalizeSpace(optString) {\n      var s = fn.string.call(this, optString);\n      return s.replace(/[ \\t\\r\\n]+/g, ' ').replace(/^ | $/g, '');\n    },\n    'translate': function translate(string, from, to) {\n      var sString = fn.string.call(this, string),\n          sFrom = fn.string(from),\n          sTo = fn.string(to);\n      var eachCharRe = [];\n      var map = {};\n\n      for (var i = 0; i < sFrom.length; ++i) {\n        var c = sFrom.charAt(i);\n        map[c] = sTo.charAt(i); // returns '' if beyond length of sTo.\n        // copied from goog.string.regExpEscape in the Closure library.\n\n        eachCharRe.push(c.replace(/([-()\\[\\]{}+?*.$\\^|,:#<!\\\\])/g, '\\\\$1').replace(/\\x08/g, '\\\\x08'));\n      }\n\n      var re = new RegExp(eachCharRe.join('|'), 'g');\n      return sString.replace(re, function (c) {\n        return map[c];\n      });\n    },\n    /// Boolean functions\n    'not': function not(x) {\n      var bx = fn['boolean'](x);\n      return !bx;\n    },\n    'true': function trueVal() {\n      return true;\n    },\n    'false': function falseVal() {\n      return false;\n    },\n    // TODO\n    'lang': function lang(string) {\n      throw new Error('Not implemented');\n    },\n    'sum': function sum(optNodeSet) {\n      if (null == optNodeSet) return fn.sum(this); // for node-sets, map id over each node value.\n\n      var sum = 0;\n\n      for (var i = 0; i < optNodeSet.nodes.length; ++i) {\n        var node = optNodeSet.nodes[i];\n        var x = fn.number({\n          nodes: [node]\n        });\n        sum += x;\n      }\n\n      return sum;\n    },\n    'floor': function floor(number) {\n      return Math.floor(fn.number(number));\n    },\n    'ceiling': function ceiling(number) {\n      return Math.ceil(fn.number(number));\n    },\n    'round': function round(number) {\n      return Math.round(fn.number(number));\n    }\n  };\n  /***************************************************************************\n   *                         Evaluation: operators                           *\n   ***************************************************************************/\n\n  var more = {\n    UnaryMinus: function (x) {\n      return -fn.number(x);\n    },\n    '+': function (x, y) {\n      return fn.number(x) + fn.number(y);\n    },\n    '-': function (x, y) {\n      return fn.number(x) - fn.number(y);\n    },\n    '*': function (x, y) {\n      return fn.number(x) * fn.number(y);\n    },\n    'div': function (x, y) {\n      return fn.number(x) / fn.number(y);\n    },\n    'mod': function (x, y) {\n      return fn.number(x) % fn.number(y);\n    },\n    '<': function (x, y) {\n      return comparisonHelper(function (x, y) {\n        return fn.number(x) < fn.number(y);\n      }, x, y, true);\n    },\n    '<=': function (x, y) {\n      return comparisonHelper(function (x, y) {\n        return fn.number(x) <= fn.number(y);\n      }, x, y, true);\n    },\n    '>': function (x, y) {\n      return comparisonHelper(function (x, y) {\n        return fn.number(x) > fn.number(y);\n      }, x, y, true);\n    },\n    '>=': function (x, y) {\n      return comparisonHelper(function (x, y) {\n        return fn.number(x) >= fn.number(y);\n      }, x, y, true);\n    },\n    'and': function (x, y) {\n      return fn['boolean'](x) && fn['boolean'](y);\n    },\n    'or': function (x, y) {\n      return fn['boolean'](x) || fn['boolean'](y);\n    },\n    '|': function (x, y) {\n      return {\n        nodes: mergeNodeLists(x.nodes, y.nodes)\n      };\n    },\n    '=': function (x, y) {\n      // optimization for two node-sets case: avoid n^2 comparisons.\n      if ('object' === typeof x && 'object' === typeof y) {\n        var aMap = {};\n\n        for (var i = 0; i < x.nodes.length; ++i) {\n          var s = fn.string({\n            nodes: [x.nodes[i]]\n          });\n          aMap[s] = true;\n        }\n\n        for (var i = 0; i < y.nodes.length; ++i) {\n          var s = fn.string({\n            nodes: [y.nodes[i]]\n          });\n          if (aMap[s]) return true;\n        }\n\n        return false;\n      } else {\n        return comparisonHelper(function (x, y) {\n          return x === y;\n        }, x, y);\n      }\n    },\n    '!=': function (x, y) {\n      // optimization for two node-sets case: avoid n^2 comparisons.\n      if ('object' === typeof x && 'object' === typeof y) {\n        if (0 === x.nodes.length || 0 === y.nodes.length) return false;\n        var aMap = {};\n\n        for (var i = 0; i < x.nodes.length; ++i) {\n          var s = fn.string({\n            nodes: [x.nodes[i]]\n          });\n          aMap[s] = true;\n        }\n\n        for (var i = 0; i < y.nodes.length; ++i) {\n          var s = fn.string({\n            nodes: [y.nodes[i]]\n          });\n          if (!aMap[s]) return true;\n        }\n\n        return false;\n      } else {\n        return comparisonHelper(function (x, y) {\n          return x !== y;\n        }, x, y);\n      }\n    }\n  };\n  var nodeTypes = xpath.nodeTypes = {\n    'node': 0,\n    'attribute': 2,\n    'comment': 8,\n    // this.doc.COMMENT_NODE,\n    'text': 3,\n    // this.doc.TEXT_NODE,\n    'processing-instruction': 7,\n    // this.doc.PROCESSING_INSTRUCTION_NODE,\n    'element': 1 //this.doc.ELEMENT_NODE\n\n  };\n  /** For debugging and unit tests: returnjs a stringified version of the\n   * argument. */\n\n  var stringifyObject = xpath.stringifyObject = function stringifyObject(ctx) {\n    var seenKey = 'seen' + Math.floor(Math.random() * 1000000000);\n    return JSON.stringify(helper(ctx));\n\n    function helper(ctx) {\n      if (Array.isArray(ctx)) {\n        return ctx.map(function (x) {\n          return helper(x);\n        });\n      }\n\n      if ('object' !== typeof ctx) return ctx;\n      if (null == ctx) return ctx; //  if (ctx.toString) return ctx.toString();\n\n      if (null != ctx.outerHTML) return ctx.outerHTML;\n      if (null != ctx.nodeValue) return ctx.nodeName + '=' + ctx.nodeValue;\n      if (ctx[seenKey]) return '[circular]';\n      ctx[seenKey] = true;\n      var nicer = {};\n\n      for (var key in ctx) {\n        if (seenKey === key) continue;\n\n        try {\n          nicer[key] = helper(ctx[key]);\n        } catch (e) {\n          nicer[key] = '[exception: ' + e.message + ']';\n        }\n      }\n\n      delete ctx[seenKey];\n      return nicer;\n    }\n  };\n\n  var Evaluator = xpath.Evaluator = function Evaluator(doc) {\n    this.doc = doc;\n  };\n\n  Evaluator.prototype = {\n    val: function val(ast, ctx) {\n      console.assert(ctx.nodes);\n      if ('number' === typeof ast || 'string' === typeof ast) return ast;\n\n      if (more[ast[0]]) {\n        var evaluatedParams = [];\n\n        for (var i = 1; i < ast.length; ++i) {\n          evaluatedParams.push(this.val(ast[i], ctx));\n        }\n\n        var r = more[ast[0]].apply(ctx, evaluatedParams);\n        return r;\n      }\n\n      switch (ast[0]) {\n        case 'Root':\n          return {\n            nodes: [this.doc]\n          };\n\n        case 'FunctionCall':\n          var functionName = ast[1],\n              functionParams = ast[2];\n          if (null == fn[functionName]) throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'Unknown function: ' + functionName);\n          var evaluatedParams = [];\n\n          for (var i = 0; i < functionParams.length; ++i) {\n            evaluatedParams.push(this.val(functionParams[i], ctx));\n          }\n\n          var r = fn[functionName].apply(ctx, evaluatedParams);\n          return r;\n\n        case 'Predicate':\n          var lhs = this.val(ast[1], ctx);\n          var ret = {\n            nodes: []\n          };\n          var contexts = eachContext(lhs);\n\n          for (var i = 0; i < contexts.length; ++i) {\n            var singleNodeSet = contexts[i];\n            var rhs = this.val(ast[2], singleNodeSet);\n            var success;\n\n            if ('number' === typeof rhs) {\n              success = rhs === singleNodeSet.pos[0][0];\n            } else {\n              success = fn['boolean'](rhs);\n            }\n\n            if (success) {\n              var node = singleNodeSet.nodes[0];\n              ret.nodes.push(node); // skip over all the rest of the same node.\n\n              while (i + 1 < contexts.length && node === contexts[i + 1].nodes[0]) {\n                i++;\n              }\n            }\n          }\n\n          return ret;\n\n        case 'PathExpr':\n          // turn the path into an expressoin; i.e., remove the position\n          // information of the last axis.\n          var x = this.val(ast[1], ctx); // Make the nodeset a forward-direction-only one.\n\n          if (x.finalize) {\n            // it is a NodeMultiSet\n            for (var i = 0; i < x.nodes.length; ++i) {\n              console.assert(null != x.nodes[i].nodeType);\n            }\n\n            return {\n              nodes: x.nodes\n            };\n          } else {\n            return x;\n          }\n\n        case '/':\n          // TODO: don't generate '/' nodes, just Axis nodes.\n          var lhs = this.val(ast[1], ctx);\n          console.assert(null != lhs);\n          var r = this.val(ast[2], lhs);\n          console.assert(null != r);\n          return r;\n\n        case 'Axis':\n          // All the axis tests from Step. We only get AxisSpecifier NodeTest,\n          // not the predicate (which is applied later)\n          var axis = ast[1],\n              nodeType = ast[2],\n              nodeTypeNum = nodeTypes[nodeType],\n              shouldLowerCase = true,\n              // TODO: give option\n          nodeName = ast[3] && shouldLowerCase ? ast[3].toLowerCase() : ast[3];\n          nodeName = nodeName === '*' ? null : nodeName;\n          if ('object' !== typeof ctx) return {\n            nodes: [],\n            pos: []\n          };\n          var nodeList = ctx.nodes.slice(); // TODO: is copy needed?\n\n          var r = axes[axis](nodeList\n          /*destructive!*/\n          , nodeTypeNum, nodeName, shouldLowerCase);\n          return r;\n      }\n    }\n  };\n\n  var evaluate = xpath.evaluate = function evaluate(expr, doc, context) {\n    //var astFactory = new AstEvaluatorFactory(doc, context);\n    var stream = new Stream(expr);\n    var ast = parse(stream, astFactory);\n    var val = new Evaluator(doc).val(ast, {\n      nodes: [context]\n    });\n    return val;\n  };\n  /***************************************************************************\n   *                           DOM interface                                 *\n   ***************************************************************************/\n\n\n  var XPathException = xpath.XPathException = function XPathException(code, message) {\n    var e = new Error(message);\n    e.name = 'XPathException';\n    e.code = code;\n    return e;\n  };\n\n  XPathException.INVALID_EXPRESSION_ERR = 51;\n  XPathException.TYPE_ERR = 52;\n\n  var XPathEvaluator = xpath.XPathEvaluator = function XPathEvaluator() {};\n\n  XPathEvaluator.prototype = {\n    createExpression: function (expression, resolver) {\n      return new XPathExpression(expression, resolver);\n    },\n    createNSResolver: function (nodeResolver) {// TODO\n    },\n    evaluate: function evaluate(expression, contextNode, resolver, type, result) {\n      var expr = new XPathExpression(expression, resolver);\n      return expr.evaluate(contextNode, type, result);\n    }\n  };\n\n  var XPathExpression = xpath.XPathExpression = function XPathExpression(expression, resolver, optDoc) {\n    var stream = new Stream(expression);\n    this._ast = parse(stream, astFactory);\n    this._doc = optDoc;\n  };\n\n  XPathExpression.prototype = {\n    evaluate: function evaluate(contextNode, type, result) {\n      if (null == contextNode.nodeType) throw new Error('bad argument (expected context node): ' + contextNode);\n      var doc = contextNode.ownerDocument || contextNode;\n\n      if (null != this._doc && this._doc !== doc) {\n        throw new core.DOMException(core.WRONG_DOCUMENT_ERR, 'The document must be the same as the context node\\'s document.');\n      }\n\n      var evaluator = new Evaluator(doc);\n      var value = evaluator.val(this._ast, {\n        nodes: [contextNode]\n      });\n      if (XPathResult.NUMBER_TYPE === type) value = fn.number(value);else if (XPathResult.STRING_TYPE === type) value = fn.string(value);else if (XPathResult.BOOLEAN_TYPE === type) value = fn['boolean'](value);else if (XPathResult.ANY_TYPE !== type && XPathResult.UNORDERED_NODE_ITERATOR_TYPE !== type && XPathResult.ORDERED_NODE_ITERATOR_TYPE !== type && XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE !== type && XPathResult.ORDERED_NODE_SNAPSHOT_TYPE !== type && XPathResult.ANY_UNORDERED_NODE_TYPE !== type && XPathResult.FIRST_ORDERED_NODE_TYPE !== type) throw new core.DOMException(core.NOT_SUPPORTED_ERR, 'You must provide an XPath result type (0=any).');else if (XPathResult.ANY_TYPE !== type && 'object' !== typeof value) throw new XPathException(XPathException.TYPE_ERR, 'Value should be a node-set: ' + value);\n      return new XPathResult(doc, value, type);\n    }\n  };\n\n  var XPathResult = xpath.XPathResult = function XPathResult(doc, value, resultType) {\n    this._value = value;\n    this._resultType = resultType;\n    this._i = 0;\n    this._invalidated = false;\n\n    if (this.resultType === XPathResult.UNORDERED_NODE_ITERATOR_TYPE || this.resultType === XPathResult.ORDERED_NODE_ITERATOR_TYPE) {\n      doc.addEventListener('DOMSubtreeModified', invalidate, true);\n      var self = this;\n\n      function invalidate() {\n        self._invalidated = true;\n        doc.removeEventListener('DOMSubtreeModified', invalidate, true);\n      }\n    }\n  };\n\n  XPathResult.ANY_TYPE = 0;\n  XPathResult.NUMBER_TYPE = 1;\n  XPathResult.STRING_TYPE = 2;\n  XPathResult.BOOLEAN_TYPE = 3;\n  XPathResult.UNORDERED_NODE_ITERATOR_TYPE = 4;\n  XPathResult.ORDERED_NODE_ITERATOR_TYPE = 5;\n  XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE = 6;\n  XPathResult.ORDERED_NODE_SNAPSHOT_TYPE = 7;\n  XPathResult.ANY_UNORDERED_NODE_TYPE = 8;\n  XPathResult.FIRST_ORDERED_NODE_TYPE = 9;\n  var proto = {\n    // XPathResultType\n    get resultType() {\n      if (this._resultType) return this._resultType;\n\n      switch (typeof this._value) {\n        case 'number':\n          return XPathResult.NUMBER_TYPE;\n\n        case 'string':\n          return XPathResult.STRING_TYPE;\n\n        case 'boolean':\n          return XPathResult.BOOLEAN_TYPE;\n\n        default:\n          return XPathResult.UNORDERED_NODE_ITERATOR_TYPE;\n      }\n    },\n\n    get numberValue() {\n      if (XPathResult.NUMBER_TYPE !== this.resultType) throw new XPathException(XPathException.TYPE_ERR, 'You should have asked for a NUMBER_TYPE.');\n      return this._value;\n    },\n\n    get stringValue() {\n      if (XPathResult.STRING_TYPE !== this.resultType) throw new XPathException(XPathException.TYPE_ERR, 'You should have asked for a STRING_TYPE.');\n      return this._value;\n    },\n\n    get booleanValue() {\n      if (XPathResult.BOOLEAN_TYPE !== this.resultType) throw new XPathException(XPathException.TYPE_ERR, 'You should have asked for a BOOLEAN_TYPE.');\n      return this._value;\n    },\n\n    get singleNodeValue() {\n      if (XPathResult.ANY_UNORDERED_NODE_TYPE !== this.resultType && XPathResult.FIRST_ORDERED_NODE_TYPE !== this.resultType) throw new XPathException(XPathException.TYPE_ERR, 'You should have asked for a FIRST_ORDERED_NODE_TYPE.');\n      return this._value.nodes[0] || null;\n    },\n\n    get invalidIteratorState() {\n      if (XPathResult.UNORDERED_NODE_ITERATOR_TYPE !== this.resultType && XPathResult.ORDERED_NODE_ITERATOR_TYPE !== this.resultType) return false;\n      return !!this._invalidated;\n    },\n\n    get snapshotLength() {\n      if (XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE !== this.resultType && XPathResult.ORDERED_NODE_SNAPSHOT_TYPE !== this.resultType) throw new XPathException(XPathException.TYPE_ERR, 'You should have asked for a ORDERED_NODE_SNAPSHOT_TYPE.');\n      return this._value.nodes.length;\n    },\n\n    iterateNext: function iterateNext() {\n      if (XPathResult.UNORDERED_NODE_ITERATOR_TYPE !== this.resultType && XPathResult.ORDERED_NODE_ITERATOR_TYPE !== this.resultType) throw new XPathException(XPathException.TYPE_ERR, 'You should have asked for a ORDERED_NODE_ITERATOR_TYPE.');\n      if (this.invalidIteratorState) throw new core.DOMException(core.INVALID_STATE_ERR, 'The document has been mutated since the result was returned');\n      return this._value.nodes[this._i++] || null;\n    },\n    snapshotItem: function snapshotItem(index) {\n      if (XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE !== this.resultType && XPathResult.ORDERED_NODE_SNAPSHOT_TYPE !== this.resultType) throw new XPathException(XPathException.TYPE_ERR, 'You should have asked for a ORDERED_NODE_SNAPSHOT_TYPE.');\n      return this._value.nodes[index] || null;\n    }\n  }; // so you can access ANY_TYPE etc. from the instances:\n\n  XPathResult.prototype = Object.create(XPathResult, Object.keys(proto).reduce(function (descriptors, name) {\n    descriptors[name] = Object.getOwnPropertyDescriptor(proto, name);\n    return descriptors;\n  }, {\n    constructor: {\n      value: XPathResult,\n      writable: true,\n      configurable: true\n    }\n  }));\n  core.XPathException = XPathException;\n  core.XPathExpression = XPathExpression;\n  core.XPathResult = XPathResult;\n  core.XPathEvaluator = XPathEvaluator;\n  core.Document.prototype.createExpression = XPathEvaluator.prototype.createExpression;\n  core.Document.prototype.createNSResolver = XPathEvaluator.prototype.createNSResolver;\n  core.Document.prototype.evaluate = XPathEvaluator.prototype.evaluate;\n})();","map":{"version":3,"sources":["F:/JavaScript/Projects/chemistryphile/node_modules/jsdom-no-contextify/lib/jsdom/level3/xpath.js"],"names":["xpath","core","require","exports","Stream","str","original","peeked","prev","prevprev","prototype","peek","m","re","exec","substr","length","peek2","pop","r","trypop","tokens","tok","Array","isArray","i","t","trypopfuncname","isQnameRe","test","trypopaxisname","trypopnametest","startsWithNcNameRe","trypopliteral","first","charAt","last","trypopnumber","isNumberRe","parseFloat","trypopvarref","position","nameStartCharsExceptColon","nameCharExceptColon","ncNameChars","qNameChars","otherChars","operatorChars","literal","numberChars","variableReference","nameTestChars","optionalSpace","nodeType","RegExp","parse","stream","a","orExpr","x","unparsed","push","XPathException","INVALID_EXPRESSION_ERR","join","binaryL","subExpr","ops","lhs","op","rhs","node","binaryR","locationPath","absoluteLocationPath","relativeLocationPath","isOnlyRootOk","step","undefined","abbrStep","axis","axisSpecifier","nodeTypeTest","nodeName","nodeNameTest","pred","predicate","attr","axisName","coloncolon","type","param","name","expr","primaryExpr","varRef","funCall","functionCall","e","params","unionExpr","pathExpr","filter","filterExpr","loc","Error","rel","primary","orig","andExpr","now","equalityExpr","relationalExpr","additiveExpr","multiplicativeExpr","unaryExpr","astFactory","slice","call","arguments","optimize","ast","NodeMultiSet","isReverseAxis","nodes","pos","lasts","nextPos","seriesIndexes","_pushToNodes","unshift","pushSeries","popSeries","console","assert","indexInPos","seriesBeginIndex","seriesEndIndex","finalize","j","JSON","stringify","addNode","simplify","eachContext","nodeMultiSet","NodeMatcher","nodeTypeNum","shouldLowerCase","_alwaysTrue","_nodeNameLowerCaseEquals","_nodeNameEquals","matches","toLowerCase","followingSiblingHelper","nodeList","shift","followingNode","andSelf","matcher","numPushed","followingNonDescendantNode","ownerElement","firstChild","nextSibling","parentNode","precedingNode","previousSibling","lastChild","followingHelper","cursor","unorderedFollowingStarts","start","started","splice","precedingHelper","nextParents","someoneUsed","descendantDfs","remaining","attrIndices","attrNodes","pushed","childNodes","child","descenantHelper","ancestorHelper","ancestors","isFirst","newCtx","addressVector","addressComparator","b","minlen","Math","min","alen","blen","c","sortUniqDocumentOrder","v","sort","sortNodeMultiSet","n","p","l","compare","y","nodeAndAncestors","compareSiblings","stringifyObject","mergeNodeLists","aanc","banc","comparisonHelper","isNumericComparison","coersion","fn","number","string","aMap","xi","yj","yc","yi","xc","axes","ancestor","ancestorOrSelf","attribute","getAttributeNode","attributes","childList","children","descenant","descenantOrSelf","following","followingSibling","namespace","parent","preceding","precedingSibling","self","optObject","textContent","nodeValue","booleanVal","count","nodeSet","id","object","doc","ownerDocument","ids","idNode","idsString","split","apply","getElementById","concat","startsWith","as","bs","contains","indexOf","substringBefore","substring","optEnd","sString","iStart","round","iEnd","stringLength","optString","normalizeSpace","s","replace","translate","from","to","sFrom","sTo","eachCharRe","map","not","bx","trueVal","falseVal","lang","sum","optNodeSet","floor","ceiling","ceil","more","UnaryMinus","nodeTypes","ctx","seenKey","random","helper","outerHTML","nicer","key","message","Evaluator","val","evaluatedParams","functionName","functionParams","ret","contexts","singleNodeSet","success","evaluate","context","code","TYPE_ERR","XPathEvaluator","createExpression","expression","resolver","XPathExpression","createNSResolver","nodeResolver","contextNode","result","optDoc","_ast","_doc","DOMException","WRONG_DOCUMENT_ERR","evaluator","value","XPathResult","NUMBER_TYPE","STRING_TYPE","BOOLEAN_TYPE","ANY_TYPE","UNORDERED_NODE_ITERATOR_TYPE","ORDERED_NODE_ITERATOR_TYPE","UNORDERED_NODE_SNAPSHOT_TYPE","ORDERED_NODE_SNAPSHOT_TYPE","ANY_UNORDERED_NODE_TYPE","FIRST_ORDERED_NODE_TYPE","NOT_SUPPORTED_ERR","resultType","_value","_resultType","_i","_invalidated","addEventListener","invalidate","removeEventListener","proto","numberValue","stringValue","booleanValue","singleNodeValue","invalidIteratorState","snapshotLength","iterateNext","INVALID_STATE_ERR","snapshotItem","index","Object","create","keys","reduce","descriptors","getOwnPropertyDescriptor","constructor","writable","configurable","Document"],"mappings":"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","sourcesContent":["/** Here is yet another implementation of XPath 1.0 in Javascript.\n *\n * My goal was to make it relatively compact, but as I fixed all the axis bugs\n * the axes became more and more complicated. :-(.\n *\n * I have not implemented namespaces or case-sensitive axes for XML yet.\n *\n * How to test it in Chrome: You can make a Chrome extension that replaces\n * the WebKit XPath parser with this one. But it takes a bit of effort to\n * get around isolated world and same-origin restrictions:\n * manifest.json:\n    {\n      \"name\": \"XPathTest\",\n      \"version\": \"0.1\",\n      \"content_scripts\": [{\n        \"matches\": [\"http://localhost/*\"],  // or wildcard host\n        \"js\": [\"xpath.js\", \"injection.js\"],\n        \"all_frames\": true, \"run_at\": \"document_start\"\n      }]\n    }\n * injection.js:\n    // goal: give my xpath object to the website's JS context.\n    var script = document.createElement('script');\n    script.textContent =\n        \"document.addEventListener('xpathextend', function(e) {\\n\" +\n        \"  console.log('extending document with xpath...');\\n\" +\n        \"  e.detail(window);\" +\n        \"});\";\n    document.documentElement.appendChild(script);\n    document.documentElement.removeChild(script);\n    var evt = document.createEvent('CustomEvent');\n    evt.initCustomEvent('xpathextend', true, true, this.xpath.extend);\n    document.dispatchEvent(evt);\n */\n(function() {\n  var xpath;\n  var core;\n  if ('function' === typeof require) {\n    xpath = exports; // the tests go through this\n    core = require(\"../level1/core\");\n  } else {\n    xpath = {};\n    core = this;\n  }\n\n\n  /***************************************************************************\n   *                            Tokenization                                 *\n   ***************************************************************************/\n  /**\n   * The XPath lexer is basically a single regular expression, along with\n   * some helper functions to pop different types.\n   */\n  var Stream = xpath.Stream = function Stream(str) {\n    this.original = this.str = str;\n    this.peeked = null;\n    // TODO: not really needed, but supposedly tokenizer also disambiguates\n    // a * b vs. node test *\n    this.prev = null;  // for debugging\n    this.prevprev = null;\n  }\n  Stream.prototype = {\n    peek: function() {\n      if (this.peeked) return this.peeked;\n      var m = this.re.exec(this.str);\n      if (!m) return null;\n      this.str = this.str.substr(m[0].length);\n      return this.peeked = m[1];\n    },\n    /** Peek 2 tokens ahead. */\n    peek2: function() {\n      this.peek();  // make sure this.peeked is set\n      var m = this.re.exec(this.str);\n      if (!m) return null;\n      return m[1];\n    },\n    pop: function() {\n      var r = this.peek();\n      this.peeked = null;\n      this.prevprev = this.prev;\n      this.prev = r;\n      return r;\n    },\n    trypop: function(tokens) {\n      var tok = this.peek();\n      if (tok === tokens) return this.pop();\n      if (Array.isArray(tokens)) {\n        for (var i = 0; i < tokens.length; ++i) {\n          var t = tokens[i];\n          if (t == tok) return this.pop();;\n        }\n      }\n    },\n    trypopfuncname: function() {\n      var tok = this.peek();\n      if (!this.isQnameRe.test(tok))\n        return null;\n      switch (tok) {\n        case 'comment': case 'text': case 'processing-instruction': case 'node':\n          return null;\n      }\n      if ('(' != this.peek2()) return null;\n      return this.pop();\n    },\n    trypopaxisname: function() {\n      var tok = this.peek();\n      switch (tok) {\n        case 'ancestor': case 'ancestor-or-self': case 'attribute':\n        case 'child': case 'descendant': case 'descendant-or-self':\n        case 'following': case 'following-sibling': case 'namespace':\n        case 'parent': case 'preceding': case 'preceding-sibling': case 'self':\n          if ('::' == this.peek2()) return this.pop();\n      }\n      return null;\n    },\n    trypopnametest: function() {\n      var tok = this.peek();\n      if ('*' === tok || this.startsWithNcNameRe.test(tok)) return this.pop();\n      return null;\n    },\n    trypopliteral: function() {\n      var tok = this.peek();\n      if (null == tok) return null;\n      var first = tok.charAt(0);\n      var last = tok.charAt(tok.length - 1);\n      if ('\"' === first && '\"' === last ||\n          \"'\" === first && \"'\" === last) {\n        this.pop();\n        return tok.substr(1, tok.length - 2);\n      }\n    },\n    trypopnumber: function() {\n      var tok = this.peek();\n      if (this.isNumberRe.test(tok)) return parseFloat(this.pop());\n      else return null;\n    },\n    trypopvarref: function() {\n      var tok = this.peek();\n      if (null == tok) return null;\n      if ('$' === tok.charAt(0)) return this.pop().substr(1);\n      else return null;\n    },\n    position: function() {\n      return this.original.length - this.str.length;\n    }\n  };\n  (function() {\n    // http://www.w3.org/TR/REC-xml-names/#NT-NCName\n    var nameStartCharsExceptColon =\n        'A-Z_a-z\\xc0-\\xd6\\xd8-\\xf6\\xF8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF' +\n        '\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF' +\n        '\\uFDF0-\\uFFFD';  // JS doesn't support [#x10000-#xEFFFF]\n    var nameCharExceptColon = nameStartCharsExceptColon +\n        '\\\\-\\\\.0-9\\xb7\\u0300-\\u036F\\u203F-\\u2040';\n    var ncNameChars = '[' + nameStartCharsExceptColon +\n        '][' + nameCharExceptColon + ']*'\n    // http://www.w3.org/TR/REC-xml-names/#NT-QName\n    var qNameChars = ncNameChars + '(?::' + ncNameChars + ')?';\n    var otherChars = '\\\\.\\\\.|[\\\\(\\\\)\\\\[\\\\].@,]|::';  // .. must come before [.]\n    var operatorChars =\n        'and|or|mod|div|' +\n        '//|!=|<=|>=|[*/|+\\\\-=<>]';  // //, !=, <=, >= before individual ones.\n    var literal = '\"[^\"]*\"|' + \"'[^']*'\";\n    var numberChars = '[0-9]+(?:\\\\.[0-9]*)?|\\\\.[0-9]+';\n    var variableReference = '\\\\$' + qNameChars;\n    var nameTestChars = '\\\\*|' + ncNameChars + ':\\\\*|' + qNameChars;\n    var optionalSpace = '[ \\t\\r\\n]*';  // stricter than regexp \\s.\n    var nodeType = 'comment|text|processing-instruction|node';\n    var re = new RegExp(\n        // numberChars before otherChars so that leading-decimal doesn't become .\n        '^' + optionalSpace + '(' + numberChars + '|' + otherChars + '|' +\n        nameTestChars + '|' + operatorChars + '|' + literal + '|' +\n        variableReference + ')'\n        // operatorName | nodeType | functionName | axisName are lumped into\n        // qName for now; we'll check them on pop.\n    );\n    Stream.prototype.re = re;\n    Stream.prototype.startsWithNcNameRe = new RegExp('^' + ncNameChars);\n    Stream.prototype.isQnameRe = new RegExp('^' + qNameChars + '$');\n    Stream.prototype.isNumberRe = new RegExp('^' + numberChars + '$');\n  })();\n\n  /***************************************************************************\n   *                               Parsing                                   *\n   ***************************************************************************/\n  var parse = xpath.parse = function parse(stream, a) {\n    var r = orExpr(stream,a);\n    var x, unparsed = [];\n    while (x = stream.pop()) {\n      unparsed.push(x);\n    }\n    if (unparsed.length)\n      throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                               'Position ' + stream.position() +\n                               ': Unparsed tokens: ' + unparsed.join(' '));\n    return r;\n  }\n\n  /**\n   * binaryL  ::= subExpr\n   *            | binaryL op subExpr\n   * so a op b op c becomes ((a op b) op c)\n   */\n  function binaryL(subExpr, stream, a, ops) {\n    var lhs = subExpr(stream, a);\n    if (lhs == null) return null;\n    var op;\n    while (op = stream.trypop(ops)) {\n      var rhs = subExpr(stream, a);\n      if (rhs == null)\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Expected something after ' + op);\n      lhs = a.node(op, lhs, rhs);\n    }\n    return lhs;\n  }\n  /**\n   * Too bad this is never used. If they made a ** operator (raise to power),\n   ( we would use it.\n   * binaryR  ::= subExpr\n   *            | subExpr op binaryR\n   * so a op b op c becomes (a op (b op c))\n   */\n  function binaryR(subExpr, stream, a, ops) {\n    var lhs = subExpr(stream, a);\n    if (lhs == null) return null;\n    var op = stream.trypop(ops);\n    if (op) {\n      var rhs = binaryR(stream, a);\n      if (rhs == null)\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Expected something after ' + op);\n      return a.node(op, lhs, rhs);\n    } else {\n      return lhs;// TODO\n    }\n  }\n  /** [1] LocationPath::= RelativeLocationPath | AbsoluteLocationPath\n   * e.g. a, a/b, //a/b\n   */\n  function locationPath(stream, a) {\n    return absoluteLocationPath(stream, a) ||\n           relativeLocationPath(null, stream, a);\n  }\n  /** [2] AbsoluteLocationPath::= '/' RelativeLocationPath? | AbbreviatedAbsoluteLocationPath\n   *  [10] AbbreviatedAbsoluteLocationPath::= '//' RelativeLocationPath\n   */\n  function absoluteLocationPath(stream, a) {\n    var op = stream.peek();\n    if ('/' === op || '//' === op) {\n      var lhs = a.node('Root');\n      return relativeLocationPath(lhs, stream, a, true);\n    } else {\n      return null;\n    }\n  }\n  /** [3] RelativeLocationPath::= Step | RelativeLocationPath '/' Step |\n   *                            | AbbreviatedRelativeLocationPath\n   *  [11] AbbreviatedRelativeLocationPath::= RelativeLocationPath '//' Step\n   * e.g. p/a, etc.\n   */\n  function relativeLocationPath(lhs, stream, a, isOnlyRootOk) {\n    if (null == lhs) {\n      lhs = step(stream, a);\n      if (null == lhs) return lhs;\n    }\n    var op;\n    while (op = stream.trypop(['/', '//'])) {\n      if ('//' === op) {\n        lhs = a.node('/', lhs,\n                     a.node('Axis', 'descendant-or-self', 'node', undefined));\n      }\n      var rhs = step(stream, a);\n      if (null == rhs && '/' === op && isOnlyRootOk) return lhs;\n      else isOnlyRootOk = false;\n      if (null == rhs)\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Expected step after ' + op);\n      lhs = a.node('/', lhs, rhs);\n    }\n    return lhs;\n  }\n  /** [4] Step::= AxisSpecifier NodeTest Predicate* | AbbreviatedStep\n   *  [12] AbbreviatedStep::= '.' | '..'\n   * e.g. @href, self::p, p, a[@href], ., ..\n   */\n  function step(stream, a) {\n    var abbrStep = stream.trypop(['.', '..']);\n    if ('.' === abbrStep)  // A location step of . is short for self::node().\n      return a.node('Axis', 'self', 'node');\n    if ('..' === abbrStep)  // A location step of .. is short for parent::node()\n      return a.node('Axis', 'parent', 'node');\n\n    var axis = axisSpecifier(stream, a);\n    var nodeType = nodeTypeTest(stream, a);\n    var nodeName;\n    if (null == nodeType) nodeName = nodeNameTest(stream, a);\n    if (null == axis && null == nodeType && null == nodeName) return null;\n    if (null == nodeType && null == nodeName)\n        throw new XPathException(\n            XPathException.INVALID_EXPRESSION_ERR,\n            'Position ' + stream.position() +\n            ': Expected nodeTest after axisSpecifier ' + axis);\n    if (null == axis) axis = 'child';\n    if (null == nodeType) {\n      // When there's only a node name, then the node type is forced to be the\n      // principal node type of the axis.\n      // see http://www.w3.org/TR/xpath/#dt-principal-node-type\n      if ('attribute' === axis) nodeType = 'attribute';\n      else if ('namespace' === axis) nodeType = 'namespace';\n      else nodeType = 'element';\n    }\n    var lhs = a.node('Axis', axis, nodeType, nodeName);\n    var pred;\n    while (null != (pred = predicate(lhs, stream, a))) {\n      lhs = pred;\n    }\n    return lhs;\n  }\n  /** [5] AxisSpecifier::= AxisName '::' | AbbreviatedAxisSpecifier\n   *  [6] AxisName::= 'ancestor' | 'ancestor-or-self' | 'attribute' | 'child'\n   *                | 'descendant' | 'descendant-or-self' | 'following'\n   *                | 'following-sibling' | 'namespace' | 'parent' |\n   *                | 'preceding' | 'preceding-sibling' | 'self'\n   *  [13] AbbreviatedAxisSpecifier::= '@'?\n   */\n  function axisSpecifier(stream, a) {\n    var attr = stream.trypop('@');\n    if (null != attr) return 'attribute';\n    var axisName = stream.trypopaxisname();\n    if (null != axisName) {\n      var coloncolon = stream.trypop('::');\n      if (null == coloncolon)\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Should not happen. Should be ::.');\n      return axisName;\n    }\n  }\n  /** [7] NodeTest::= NameTest | NodeType '(' ')' | 'processing-instruction' '(' Literal ')'\n   *  [38] NodeType::= 'comment' | 'text' | 'processing-instruction' | 'node'\n   * I've split nodeTypeTest from nodeNameTest for convenience.\n   */\n  function nodeTypeTest(stream, a) {\n    if ('(' !== stream.peek2()) {\n      return null;\n    }\n    var type = stream.trypop(['comment', 'text', 'processing-instruction', 'node']);\n    if (null != type) {\n      if (null == stream.trypop('('))\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Should not happen.');\n      var param = undefined;\n      if (type == 'processing-instruction') {\n        param = stream.trypopliteral();\n      }\n      if (null == stream.trypop(')'))\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Expected close parens.');\n      return type\n    }\n  }\n  function nodeNameTest(stream, a) {\n    var name = stream.trypopnametest();\n    if (name != null) return name;\n    else return null;\n  }\n  /** [8] Predicate::= '[' PredicateExpr ']'\n   *  [9] PredicateExpr::= Expr\n   */\n  function predicate(lhs, stream, a) {\n    if (null == stream.trypop('[')) return null;\n    var expr = orExpr(stream, a);\n    if (null == expr)\n      throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                               'Position ' + stream.position() +\n                               ': Expected expression after [');\n    if (null == stream.trypop(']'))\n      throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                               'Position ' + stream.position() +\n                               ': Expected ] after expression.');\n    return a.node('Predicate', lhs, expr);\n  }\n  /** [14] Expr::= OrExpr\n   */\n  /** [15] PrimaryExpr::= VariableReference | '(' Expr ')' | Literal | Number | FunctionCall\n   * e.g. $x,  (3+4),  \"hi\",  32,  f(x)\n   */\n  function primaryExpr(stream, a) {\n    var x = stream.trypopliteral();\n    if (null == x)\n      x = stream.trypopnumber();\n    if (null != x) {\n      return x;\n    }\n    var varRef = stream.trypopvarref();\n    if (null != varRef) return a.node('VariableReference', varRef);\n    var funCall = functionCall(stream, a);\n    if (null != funCall) {\n      return funCall;\n    }\n    if (stream.trypop('(')) {\n      var e = orExpr(stream, a);\n      if (null == e)\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Expected expression after (.');\n      if (null == stream.trypop(')'))\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Expected ) after expression.');\n      return e;\n    }\n    return null;\n  }\n  /** [16] FunctionCall::= FunctionName '(' ( Argument ( ',' Argument )* )? ')'\n   *  [17] Argument::= Expr\n   */\n  function functionCall(stream, a) {\n    var name = stream.trypopfuncname(stream, a);\n    if (null == name) return null;\n    if (null == stream.trypop('('))\n      throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                               'Position ' + stream.position() +\n                               ': Expected ( ) after function name.');\n    var params = [];\n    var first = true;\n    while (null == stream.trypop(')')) {\n      if (!first && null == stream.trypop(','))\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Expected , between arguments of the function.');\n      first = false;\n      var param = orExpr(stream, a);\n      if (param == null)\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Expected expression as argument of function.');\n      params.push(param);\n    }\n    return a.node('FunctionCall', name, params);\n  }\n\n  /** [18] UnionExpr::= PathExpr | UnionExpr '|' PathExpr\n   */\n  function unionExpr(stream, a) { return binaryL(pathExpr, stream, a, '|'); }\n  /** [19] PathExpr ::= LocationPath\n   *                  | FilterExpr\n   *                  | FilterExpr '/' RelativeLocationPath\n   *                  | FilterExpr '//' RelativeLocationPath\n   * Unlike most other nodes, this one always generates a node because\n   * at this point all reverse nodesets must turn into a forward nodeset\n   */\n  function pathExpr(stream, a) {\n    // We have to do FilterExpr before LocationPath because otherwise\n    // LocationPath will eat up the name from a function call.\n    var filter = filterExpr(stream, a);\n    if (null == filter) {\n      var loc = locationPath(stream, a);\n      if (null == loc) {\n        throw new Error\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': The expression shouldn\\'t be empty...');\n      }\n      return a.node('PathExpr', loc);\n    }\n    var rel = relativeLocationPath(filter, stream, a, false);\n    if (filter === rel) return rel;\n    else return a.node('PathExpr', rel);\n  }\n  /** [20] FilterExpr::= PrimaryExpr | FilterExpr Predicate\n   * aka. FilterExpr ::= PrimaryExpr Predicate*\n   */\n  function filterExpr(stream, a) {\n    var primary = primaryExpr(stream, a);\n    if (primary == null) return null;\n    var pred, lhs = primary;\n    while (null != (pred = predicate(lhs, stream, a))) {\n      lhs = pred;\n    }\n    return lhs;\n  }\n\n  /** [21] OrExpr::= AndExpr | OrExpr 'or' AndExpr\n   */\n  function orExpr(stream, a) {\n    var orig = (stream.peeked || '') + stream.str\n    var r = binaryL(andExpr, stream, a, 'or');\n    var now = (stream.peeked || '') + stream.str;\n    return r;\n  }\n  /** [22] AndExpr::= EqualityExpr | AndExpr 'and' EqualityExpr\n   */\n  function andExpr(stream, a) { return binaryL(equalityExpr, stream, a, 'and'); }\n  /** [23] EqualityExpr::= RelationalExpr | EqualityExpr '=' RelationalExpr\n   *                     | EqualityExpr '!=' RelationalExpr\n   */\n  function equalityExpr(stream, a) { return binaryL(relationalExpr, stream, a, ['=','!=']); }\n  /** [24] RelationalExpr::= AdditiveExpr | RelationalExpr '<' AdditiveExpr\n   *                       | RelationalExpr '>' AdditiveExpr\n   *                       | RelationalExpr '<=' AdditiveExpr\n   *                       | RelationalExpr '>=' AdditiveExpr\n   */\n  function relationalExpr(stream, a) { return binaryL(additiveExpr, stream, a, ['<','>','<=','>=']); }\n  /** [25] AdditiveExpr::= MultiplicativeExpr\n   *                     | AdditiveExpr '+' MultiplicativeExpr\n   *                     | AdditiveExpr '-' MultiplicativeExpr\n   */\n  function additiveExpr(stream, a) { return binaryL(multiplicativeExpr, stream, a, ['+','-']); }\n  /** [26] MultiplicativeExpr::= UnaryExpr\n   *                           | MultiplicativeExpr MultiplyOperator UnaryExpr\n   *                           | MultiplicativeExpr 'div' UnaryExpr\n   *                           | MultiplicativeExpr 'mod' UnaryExpr\n   */\n  function multiplicativeExpr(stream, a) { return binaryL(unaryExpr, stream, a, ['*','div','mod']); }\n  /** [27] UnaryExpr::= UnionExpr | '-' UnaryExpr\n   */\n  function unaryExpr(stream, a) {\n    if (stream.trypop('-')) {\n      var e = unaryExpr(stream, a);\n      if (null == e)\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Expected unary expression after -');\n      return a.node('UnaryMinus', e);\n    }\n    else return unionExpr(stream, a);\n  }\n  var astFactory = {\n    node: function() {return Array.prototype.slice.call(arguments);}\n  };\n\n\n  /***************************************************************************\n   *                            Optimizations (TODO)                         *\n   ***************************************************************************/\n  /**\n   * Some things I've been considering:\n   * 1) a//b becomes a/descendant::b if there's no predicate that uses\n   *    position() or last()\n   * 2) axis[pred]: when pred doesn't use position, evaluate it just once per\n   *    node in the node-set rather than once per (node, position, last).\n   * For more optimizations, look up Gecko's optimizer:\n   * http://mxr.mozilla.org/mozilla-central/source/content/xslt/src/xpath/txXPathOptimizer.cpp\n   */\n  // TODO\n  function optimize(ast) {\n  }\n\n  /***************************************************************************\n   *                           Evaluation: axes                              *\n   ***************************************************************************/\n\n  /**\n   * Data types: For string, number, boolean, we just use Javascript types.\n   * Node-sets have the form\n   *    {nodes: [node, ...]}\n   * or {nodes: [node, ...], pos: [[1], [2], ...], lasts: [[1], [2], ...]}\n   *\n   * Most of the time, only the node is used and the position information is\n   * discarded. But if you use a predicate, we need to try every value of\n   * position and last in case the predicate calls position() or last().\n   */\n\n  /**\n   * The NodeMultiSet is a helper class to help generate\n   * {nodes:[], pos:[], lasts:[]} structures. It is useful for the\n   * descendant, descendant-or-self, following-sibling, and\n   * preceding-sibling axes for which we can use a stack to organize things.\n   */\n  function NodeMultiSet(isReverseAxis) {\n    this.nodes = [];\n    this.pos = [];\n    this.lasts = [];\n    this.nextPos = [];\n    this.seriesIndexes = [];  // index within nodes that each series begins.\n    this.isReverseAxis = isReverseAxis;\n    this._pushToNodes = isReverseAxis ? Array.prototype.unshift : Array.prototype.push;\n  }\n  NodeMultiSet.prototype = {\n    pushSeries: function pushSeries() {\n      this.nextPos.push(1);\n      this.seriesIndexes.push(this.nodes.length);\n    },\n    popSeries: function popSeries() {\n      console.assert(0 < this.nextPos.length, this.nextPos);\n      var last = this.nextPos.pop() - 1,\n          indexInPos = this.nextPos.length,\n          seriesBeginIndex = this.seriesIndexes.pop(),\n          seriesEndIndex = this.nodes.length;\n      for (var i = seriesBeginIndex; i < seriesEndIndex; ++i) {\n        console.assert(indexInPos < this.lasts[i].length);\n        console.assert(undefined === this.lasts[i][indexInPos]);\n        this.lasts[i][indexInPos] = last;\n      }\n    },\n    finalize: function() {\n      if (null == this.nextPos) return this;\n      console.assert(0 === this.nextPos.length);\n      for (var i = 0; i < this.lasts.length; ++i) {\n        for (var j = 0; j < this.lasts[i].length; ++j) {\n          console.assert(null != this.lasts[i][j], i + ',' + j + ':' + JSON.stringify(this.lasts));\n        }\n      }\n      this.pushSeries = this.popSeries = this.addNode = function() {\n        throw new Error('Already finalized.');\n      };\n      return this;\n    },\n    addNode: function addNode(node) {\n      console.assert(node);\n      this._pushToNodes.call(this.nodes, node)\n      this._pushToNodes.call(this.pos, this.nextPos.slice());\n      this._pushToNodes.call(this.lasts, new Array(this.nextPos.length));\n      for (var i = 0; i < this.nextPos.length; ++i) this.nextPos[i]++;\n    },\n    simplify: function() {\n      this.finalize();\n      return {nodes:this.nodes, pos:this.pos, lasts:this.lasts};\n    }\n  };\n  function eachContext(nodeMultiSet) {\n    var r = [];\n    for (var i = 0; i < nodeMultiSet.nodes.length; i++) {\n      var node = nodeMultiSet.nodes[i];\n      if (!nodeMultiSet.pos) {\n        r.push({nodes:[node], pos: [[i + 1]], lasts: [[nodeMultiSet.nodes.length]]});\n      } else {\n        for (var j = 0; j < nodeMultiSet.pos[i].length; ++j) {\n          r.push({nodes:[node], pos: [[nodeMultiSet.pos[i][j]]], lasts: [[nodeMultiSet.lasts[i][j]]]});\n        }\n      }\n    }\n    return r;\n  }\n  /** Matcher used in the axes.\n   */\n  function NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase) {\n    this.nodeTypeNum = nodeTypeNum;\n    this.nodeName = nodeName;\n    this.shouldLowerCase = shouldLowerCase;\n    this.nodeNameTest =\n      null == nodeName ? this._alwaysTrue :\n      shouldLowerCase ? this._nodeNameLowerCaseEquals :\n      this._nodeNameEquals;\n  }\n  NodeMatcher.prototype = {\n    matches: function matches(node) {\n      return (0 === this.nodeTypeNum || node.nodeType === this.nodeTypeNum) &&\n          this.nodeNameTest(node.nodeName);\n    },\n    _alwaysTrue: function(name) {return true;},\n    _nodeNameEquals: function _nodeNameEquals(name) {\n      return this.nodeName === name;\n    },\n    _nodeNameLowerCaseEquals: function _nodeNameLowerCaseEquals(name) {\n      return this.nodeName === name.toLowerCase();\n    }\n  };\n\n  function followingSiblingHelper(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, shift, peek, followingNode, andSelf, isReverseAxis) {\n    var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n    var nodeMultiSet = new NodeMultiSet(isReverseAxis);\n    while (0 < nodeList.length) {  // can be if for following, preceding\n      var node = shift.call(nodeList);\n      console.assert(node != null);\n      node = followingNode(node);\n      nodeMultiSet.pushSeries();\n      var numPushed = 1;\n      while (null != node) {\n        if (! andSelf && matcher.matches(node))\n          nodeMultiSet.addNode(node);\n        if (node === peek.call(nodeList)) {\n          shift.call(nodeList);\n          nodeMultiSet.pushSeries();\n          numPushed++;\n        }\n        if (andSelf && matcher.matches(node))\n          nodeMultiSet.addNode(node);\n        node = followingNode(node);\n      }\n      while (0 < numPushed--)\n        nodeMultiSet.popSeries();\n    }\n    return nodeMultiSet;\n  }\n\n  /** Returns the next non-descendant node in document order.\n   * This is the first node in following::node(), if node is the context.\n   */\n  function followingNonDescendantNode(node) {\n    if (node.ownerElement) {\n      if (node.ownerElement.firstChild)\n        return node.ownerElement.firstChild;\n      node = node.ownerElement;\n    }\n    do {\n      if (node.nextSibling) return node.nextSibling;\n    } while (node = node.parentNode);\n    return null;\n  }\n\n  /** Returns the next node in a document-order depth-first search.\n   * See the definition of document order[1]:\n   *   1) element\n   *   2) namespace nodes\n   *   3) attributes\n   *   4) children\n   *   [1]: http://www.w3.org/TR/xpath/#dt-document-order\n   */\n  function followingNode(node) {\n    if (node.ownerElement)  // attributes: following node of element.\n      node = node.ownerElement;\n    if (null != node.firstChild)\n      return node.firstChild;\n    do {\n      if (null != node.nextSibling) {\n        return node.nextSibling;\n      }\n      node = node.parentNode;\n    } while (node);\n    return null;\n  }\n  /** Returns the previous node in document order (excluding attributes\n   * and namespace nodes).\n   */\n  function precedingNode(node) {\n    if (node.ownerElement)\n      return node.ownerElement;\n    if (null != node.previousSibling) {\n      node = node.previousSibling;\n      while (null != node.lastChild) {\n        node = node.lastChild;\n      }\n      return node;\n    }\n    if (null != node.parentNode) {\n      return node.parentNode;\n    }\n    return null;\n  }\n  /** This axis is inefficient if there are many nodes in the nodeList.\n   * But I think it's a pretty useless axis so it's ok. */\n  function followingHelper(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n    var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n    var nodeMultiSet = new NodeMultiSet(false);\n    var cursor = nodeList[0];\n    var unorderedFollowingStarts = [];\n    for (var i = 0; i < nodeList.length; i++) {\n      var node = nodeList[i];\n      var start = followingNonDescendantNode(node);\n      if (start)\n        unorderedFollowingStarts.push(start);\n    }\n    if (0 === unorderedFollowingStarts.length)\n      return {nodes:[]};\n    var pos = [], nextPos = [];\n    var started = 0;\n    while (cursor = followingNode(cursor)) {\n      for (var i = unorderedFollowingStarts.length - 1; i >= 0; i--){\n        if (cursor === unorderedFollowingStarts[i]) {\n          nodeMultiSet.pushSeries();\n          unorderedFollowingStarts.splice(i,i+1);\n          started++;\n        }\n      }\n      if (started && matcher.matches(cursor)) {\n        nodeMultiSet.addNode(cursor);\n      }\n    }\n    console.assert(0 === unorderedFollowingStarts.length);\n    for (var i = 0; i < started; i++)\n      nodeMultiSet.popSeries();\n    return nodeMultiSet.finalize();\n  }\n  function precedingHelper(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n    var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n    var cursor = nodeList.pop();\n    if (null == cursor) return {nodes:{}};\n    var r = {nodes:[], pos:[], lasts:[]};\n    var nextParents = [cursor.parentNode || cursor.ownerElement], nextPos = [1];\n    while (cursor = precedingNode(cursor)) {\n      if (cursor === nodeList[nodeList.length - 1]) {\n        nextParents.push(nodeList.pop());\n        nextPos.push(1);\n      }\n      var matches = matcher.matches(cursor);\n      var pos, someoneUsed = false;\n      if (matches)\n        pos = nextPos.slice();\n\n      for (var i = 0; i < nextParents.length; ++i) {\n        if (cursor === nextParents[i]) {\n          nextParents[i] = cursor.parentNode || cursor.ownerElement;\n          if (matches) {\n            pos[i] = null;\n          }\n        } else {\n          if (matches) {\n            pos[i] = nextPos[i]++;\n            someoneUsed = true;\n          }\n        }\n      }\n      if (someoneUsed) {\n        r.nodes.unshift(cursor);\n        r.pos.unshift(pos);\n      }\n    }\n    for (var i = 0; i < r.pos.length; ++i) {\n      var lasts = [];\n      r.lasts.push(lasts);\n      for (var j = r.pos[i].length - 1; j >= 0; j--) {\n        if (null == r.pos[i][j]) {\n          r.pos[i].splice(j, j+1);\n        } else {\n          lasts.unshift(nextPos[j] - 1);\n        }\n      }\n    }\n    return r;\n  }\n\n  /** node-set, axis -> node-set */\n  function descendantDfs(nodeMultiSet, node, remaining, matcher, andSelf, attrIndices, attrNodes) {\n    while (0 < remaining.length && null != remaining[0].ownerElement) {\n      var attr = remaining.shift();\n      if (andSelf && matcher.matches(attr)) {\n        attrNodes.push(attr);\n        attrIndices.push(nodeMultiSet.nodes.length);\n      }\n    }\n    if (null != node && !andSelf) {\n      if (matcher.matches(node))\n        nodeMultiSet.addNode(node);\n    }\n    var pushed = false;\n    if (null == node) {\n      if (0 === remaining.length) return;\n      node = remaining.shift();\n      nodeMultiSet.pushSeries();\n      pushed = true;\n    } else if (0 < remaining.length && node === remaining[0]) {\n      nodeMultiSet.pushSeries();\n      pushed = true;\n      remaining.shift();\n    }\n    if (andSelf) {\n      if (matcher.matches(node))\n        nodeMultiSet.addNode(node);\n    }\n    // TODO: use optimization. Also try element.getElementsByTagName\n    // var nodeList = 1 === nodeTypeNum && null != node.children ? node.children : node.childNodes;\n    var nodeList = node.childNodes;\n    for (var j = 0; j < nodeList.length; ++j) {\n      var child = nodeList[j];\n      descendantDfs(nodeMultiSet, child, remaining, matcher, andSelf, attrIndices, attrNodes);\n    }\n    if (pushed) {\n      nodeMultiSet.popSeries();\n    }\n  }\n  function descenantHelper(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, andSelf) {\n    var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n    var nodeMultiSet = new NodeMultiSet(false);\n    var attrIndices = [], attrNodes = [];\n    while (0 < nodeList.length) {\n      // var node = nodeList.shift();\n      descendantDfs(nodeMultiSet, null, nodeList, matcher, andSelf, attrIndices, attrNodes);\n    }\n    nodeMultiSet.finalize();\n    for (var i = attrNodes.length-1; i >= 0; --i) {\n      nodeMultiSet.nodes.splice(attrIndices[i], attrIndices[i], attrNodes[i]);\n      nodeMultiSet.pos.splice(attrIndices[i], attrIndices[i], [1]);\n      nodeMultiSet.lasts.splice(attrIndices[i], attrIndices[i], [1]);\n    }\n    return nodeMultiSet;\n  }\n  /**\n   */\n  function ancestorHelper(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, andSelf) {\n    var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n    var ancestors = []; // array of non-empty arrays of matching ancestors\n    for (var i = 0; i < nodeList.length; ++i) {\n      var node = nodeList[i];\n      var isFirst = true;\n      var a = [];\n      while (null != node) {\n        if (!isFirst || andSelf) {\n          if (matcher.matches(node))\n            a.push(node);\n        }\n        isFirst = false;\n        node = node.parentNode || node.ownerElement;\n      }\n      if (0 < a.length)\n        ancestors.push(a);\n    }\n    var lasts = [];\n    for (var i = 0; i < ancestors.length; ++i) lasts.push(ancestors[i].length);\n    var nodeMultiSet = new NodeMultiSet(true);\n    var newCtx = {nodes:[], pos:[], lasts:[]};\n    while (0 < ancestors.length) {\n      var pos = [ancestors[0].length];\n      var last = [lasts[0]];\n      var node = ancestors[0].pop();\n      for (var i = ancestors.length - 1; i > 0; --i) {\n        if (node === ancestors[i][ancestors[i].length - 1]) {\n          pos.push(ancestors[i].length);\n          last.push(lasts[i]);\n          ancestors[i].pop();\n          if (0 === ancestors[i].length) {\n            ancestors.splice(i, i+1);\n            lasts.splice(i, i+1);\n          }\n        }\n      }\n      if (0 === ancestors[0].length) {\n        ancestors.shift();\n        lasts.shift();\n      }\n      newCtx.nodes.push(node);\n      newCtx.pos.push(pos);\n      newCtx.lasts.push(last);\n    }\n    return newCtx;\n  }\n  /** Helper function for sortDocumentOrder. Returns a list of indices, from the\n   * node to the root, of positions within parent.\n   * For convenience, the node is the first element of the array.\n   */\n  function addressVector(node) {\n    var r = [node];\n    if (null != node.ownerElement) {\n      node = node.ownerElement;\n      r.push(-1);\n    }\n    while (null != node) {\n      var i = 0;\n      while (null != node.previousSibling) {\n        node = node.previousSibling;\n        i++;\n      }\n      r.push(i);\n      node = node.parentNode\n    }\n    return r;\n  }\n  function addressComparator(a, b) {\n    var minlen = Math.min(a.length - 1, b.length - 1),  // not including [0]=node\n        alen = a.length,\n        blen = b.length;\n    if (a[0] === b[0]) return 0;\n    var c;\n    for (var i = 0; i < minlen; ++i) {\n      c = a[alen - i - 1] - b[blen - i - 1];\n      if (0 !== c)\n        break;\n    }\n    if (null == c || 0 === c) {\n      // All equal until one of the nodes. The longer one is the descendant.\n      c = alen - blen;\n    }\n    if (0 === c)\n      c = a.nodeName - b.nodeName;\n    if (0 === c)\n      c = 1;\n    return c;\n  }\n  var sortUniqDocumentOrder = xpath.sortUniqDocumentOrder = function(nodes) {\n    var a = [];\n    for (var i = 0; i < nodes.length; i++) {\n      var node = nodes[i];\n      var v = addressVector(node);\n      a.push(v);\n    }\n    a.sort(addressComparator);\n    var b = [];\n    for (var i = 0; i < a.length; i++) {\n      if (0 < i && a[i][0] === a[i - 1][0])\n        continue;\n      b.push(a[i][0]);\n    }\n    return b;\n  }\n  /** Sort node multiset. Does not do any de-duping. */\n  function sortNodeMultiSet(nodeMultiSet) {\n    var a = [];\n    for (var i = 0; i < nodeMultiSet.nodes.length; i++) {\n      var v = addressVector(nodeMultiSet.nodes[i]);\n      a.push({v:v, n:nodeMultiSet.nodes[i],\n              p:nodeMultiSet.pos[i], l:nodeMultiSet.lasts[i]});\n    }\n    a.sort(compare);\n    var r = {nodes:[], pos:[], lasts:[]};\n    for (var i = 0; i < a.length; ++i) {\n      r.nodes.push(a[i].n);\n      r.pos.push(a[i].p);\n      r.lasts.push(a[i].l);\n    }\n    function compare(x, y) {\n      return addressComparator(x.v, y.v);\n    }\n    return r;\n  }\n  /** Returns an array containing all the ancestors down to a node.\n   * The array starts with document.\n   */\n  function nodeAndAncestors(node) {\n    var ancestors = [node];\n    var p = node;\n    while (p = p.parentNode || p.ownerElement) {\n      ancestors.unshift(p);\n    }\n    return ancestors;\n  }\n  function compareSiblings(a, b) {\n    if (a === b) return 0;\n    var c = a;\n    while (c = c.previousSibling) {\n      if (c === b)\n        return 1;  // b < a\n    }\n    c = b;\n    while (c = c.previousSibling) {\n      if (c === a)\n        return -1;  // a < b\n    }\n    throw new Error('a and b are not siblings: ' + xpath.stringifyObject(a) + ' vs ' + xpath.stringifyObject(b));\n  }\n  /** The merge in merge-sort.*/\n  function mergeNodeLists(x, y) {\n    var a, b, aanc, banc, r = [];\n    if ('object' !== typeof x)\n      throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                               'Invalid LHS for | operator ' +\n                               '(expected node-set): ' + x);\n    if ('object' !== typeof y)\n      throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                               'Invalid LHS for | operator ' +\n                               '(expected node-set): ' + y);\n    while (true) {\n      if (null == a) {\n        a = x.shift();\n        if (null != a)\n          aanc = addressVector(a);\n      }\n      if (null == b) {\n        b = y.shift();\n        if (null != b)\n          banc = addressVector(b);\n      }\n      if (null == a || null == b) break;\n      var c = addressComparator(aanc, banc);\n      if (c < 0) {\n        r.push(a);\n        a = null;\n        aanc = null;\n      } else if (c > 0) {\n        r.push(b);\n        b = null;\n        banc = null;\n      } else if (a.nodeName < b.nodeName) {  // attributes\n        r.push(a);\n        a = null;\n        aanc = null;\n      } else if (a.nodeName > b.nodeName) {  // attributes\n        r.push(b);\n        b = null;\n        banc = null;\n      } else if (a !== b) {\n        // choose b arbitrarily\n        r.push(b);\n        b = null;\n        banc = null;\n      } else {\n        console.assert(a === b, c);\n        // just skip b without pushing it.\n        b = null;\n        banc = null;\n      }\n    }\n    while (a) {\n      r.push(a);\n      a = x.shift();\n    }\n    while (b) {\n      r.push(b);\n      b = y.shift();\n    }\n    return r;\n  }\n  function comparisonHelper(test, x, y, isNumericComparison) {\n    var coersion;\n    if (isNumericComparison)\n      coersion = fn.number;\n    else coersion =\n      'boolean' === typeof x || 'boolean' === typeof y ? fn['boolean'] :\n      'number' === typeof x || 'number' === typeof y ? fn.number :\n      fn.string;\n    if ('object' === typeof x && 'object' === typeof y) {\n      var aMap = {};\n      for (var i = 0; i < x.nodes.length; ++i) {\n        var xi = coersion({nodes:[x.nodes[i]]});\n        for (var j = 0; j < y.nodes.length; ++j) {\n          var yj = coersion({nodes:[y.nodes[j]]});\n          if (test(xi, yj)) return true;\n        }\n      }\n      return false;\n    } else if ('object' === typeof x && x.nodes && x.nodes.length) {\n      for (var i = 0; i < x.nodes.length; ++i) {\n        var xi = coersion({nodes:[x.nodes[i]]}), yc = coersion(y);\n        if (test(xi, yc))\n          return true;\n      }\n      return false;\n    } else if ('object' === typeof y && x.nodes && x.nodes.length) {\n      for (var i = 0; i < x.nodes.length; ++i) {\n        var yi = coersion({nodes:[y.nodes[i]]}), xc = coersion(x);\n        if (test(xc, yi))\n          return true;\n      }\n      return false;\n    } else {\n      var xc = coersion(x), yc = coersion(y);\n      return test(xc, yc);\n    }\n  }\n  var axes = xpath.axes = {\n    'ancestor':\n      function ancestor(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        return ancestorHelper(\n          nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, false);\n      },\n    'ancestor-or-self':\n      function ancestorOrSelf(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        return ancestorHelper(\n          nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, true);\n      },\n    'attribute':\n      function attribute(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        // TODO: figure out whether positions should be undefined here.\n        var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n        var nodeMultiSet = new NodeMultiSet(false);\n        if (null != nodeName) {\n          // TODO: with namespace\n          for (var i = 0; i < nodeList.length; ++i) {\n            var node = nodeList[i];\n            if (null == node.getAttributeNode)\n              continue;  // only Element has .getAttributeNode\n            var attr = node.getAttributeNode(nodeName);\n            if (null != attr && matcher.matches(attr)) {\n              nodeMultiSet.pushSeries();\n              nodeMultiSet.addNode(attr);\n              nodeMultiSet.popSeries();\n            }\n          }\n        } else {\n          for (var i = 0; i < nodeList.length; ++i) {\n            var node = nodeList[i];\n            if (null != node.attributes) {\n              nodeMultiSet.pushSeries();\n              for (var j = 0; j < node.attributes.length; j++) {  // all nodes have .attributes\n                var attr = node.attributes[j];\n                if (matcher.matches(attr))  // TODO: I think this check is unnecessary\n                  nodeMultiSet.addNode(attr);\n              }\n              nodeMultiSet.popSeries();\n            }\n          }\n        }\n        return nodeMultiSet.finalize();\n      },\n    'child':\n      function child(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n        var nodeMultiSet = new NodeMultiSet(false);\n        for (var i = 0; i < nodeList.length; ++i) {\n          var n = nodeList[i];\n          if (n.ownerElement)  // skip attribute nodes' text child.\n            continue;\n          if (n.childNodes) {\n            nodeMultiSet.pushSeries();\n            var childList = 1 === nodeTypeNum && null != n.children ?\n                n.children : n.childNodes;\n            for (var j = 0; j < childList.length; ++j) {\n              var child = childList[j];\n              if (matcher.matches(child)) {\n                nodeMultiSet.addNode(child);\n              }\n              // don't have to do de-duping because children have parent,\n              // which are current context.\n            }\n            nodeMultiSet.popSeries();\n          }\n        }\n        nodeMultiSet.finalize();\n        return sortNodeMultiSet(nodeMultiSet);\n      },\n    'descendant':\n      function descenant(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        return descenantHelper(\n          nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, false);\n      },\n    'descendant-or-self':\n      function descenantOrSelf(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        return descenantHelper(\n          nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, true);\n      },\n    'following':\n      function following(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        return followingHelper(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase);\n      },\n    'following-sibling':\n      function followingSibling(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        return followingSiblingHelper(\n          nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase,\n          Array.prototype.shift, function() {return this[0];},\n          function(node) {return node.nextSibling;});\n      },\n    'namespace':\n      function namespace(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        // TODO\n      },\n    'parent':\n      function parent(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n        var nodes = [], pos = [];\n        for (var i = 0; i < nodeList.length; ++i) {\n          var parent = nodeList[i].parentNode || nodeList[i].ownerElement;\n          if (null == parent)\n            continue;\n          if (!matcher.matches(parent))\n            continue;\n          if (nodes.length > 0 && parent === nodes[nodes.length-1])\n            continue;\n          nodes.push(parent);\n          pos.push([1]);\n        }\n        return {nodes:nodes, pos:pos, lasts:pos};\n      },\n    'preceding':\n      function preceding(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        return precedingHelper(\n          nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase);\n      },\n    'preceding-sibling':\n      function precedingSibling(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        return followingSiblingHelper(\n          nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase,\n          Array.prototype.pop, function() {return this[this.length-1];},\n          function(node) {return node.previousSibling},\n          false, true);\n      },\n    'self':\n      function self(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        var nodes = [], pos = [];\n        var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n        for (var i = 0; i < nodeList.length; ++i) {\n          if (matcher.matches(nodeList[i])) {\n            nodes.push(nodeList[i]);\n            pos.push([1]);\n          }\n        }\n        return {nodes: nodes, pos: pos, lasts: pos}\n      }\n  };\n\n  /***************************************************************************\n   *                         Evaluation: functions                           *\n   ***************************************************************************/\n  var fn = {\n    'number': function number(optObject) {\n      if ('number' === typeof optObject)\n        return optObject;\n      if ('string' === typeof optObject)\n        return parseFloat(optObject);  // note: parseFloat(' ') -> NaN, unlike +' ' -> 0.\n      if ('boolean' === typeof optObject)\n        return +optObject;\n      return fn.number(fn.string.call(this, optObject));  // for node-sets\n    },\n    'string': function string(optObject) {\n      if (null == optObject)\n        return fn.string(this);\n      if ('string' === typeof optObject || 'boolean' === typeof optObject ||\n          'number' === typeof optObject)\n        return '' + optObject;\n      if (0 == optObject.nodes.length) return '';\n      if (null != optObject.nodes[0].textContent)\n        return optObject.nodes[0].textContent;\n      return optObject.nodes[0].nodeValue;\n    },\n    'boolean': function booleanVal(x) {\n      return 'object' === typeof x ? x.nodes.length > 0 : !!x;\n    },\n    'last': function last() {\n      console.assert(Array.isArray(this.pos));\n      console.assert(Array.isArray(this.lasts));\n      console.assert(1 === this.pos.length);\n      console.assert(1 === this.lasts.length);\n      console.assert(1 === this.lasts[0].length);\n      return this.lasts[0][0];\n    },\n    'position': function position() {\n      console.assert(Array.isArray(this.pos));\n      console.assert(Array.isArray(this.lasts));\n      console.assert(1 === this.pos.length);\n      console.assert(1 === this.lasts.length);\n      console.assert(1 === this.pos[0].length);\n      return this.pos[0][0];\n    },\n    'count': function count(nodeSet) {\n      if ('object' !== typeof nodeSet)\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Function count(node-set) ' +\n                                 'got wrong argument type: ' + nodeSet);\n      return nodeSet.nodes.length;\n    },\n    'id': function id(object) {\n      var r = {nodes: []};\n      var doc = this.nodes[0].ownerDocument || this.nodes[0];\n      console.assert(doc);\n      var ids;\n      if ('object' === typeof object) {\n        // for node-sets, map id over each node value.\n        ids = [];\n        for (var i = 0; i < object.nodes.length; ++i) {\n          var idNode = object.nodes[i];\n          var idsString = fn.string({nodes:[idNode]});\n          var a = idsString.split(/[ \\t\\r\\n]+/g);\n          Array.prototype.push.apply(ids, a);\n        }\n      } else {\n        var idsString = fn.string(object);\n        var a = idsString.split(/[ \\t\\r\\n]+/g);\n        ids = a;\n      }\n      for (var i = 0; i < ids.length; ++i) {\n        var id = ids[i];\n        if (0 === id.length)\n          continue;\n        var node = doc.getElementById(id);\n        if (null != node)\n          r.nodes.push(node);\n      }\n      r.nodes = sortUniqDocumentOrder(r.nodes);\n      return r;\n    },\n    'local-name': function(nodeSet) {\n      if (null == nodeSet)\n        return fn.name(this);\n      if (null == nodeSet.nodes) {\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'argument to name() must be a node-set. got ' + nodeSet);\n      }\n      // TODO: namespaced version\n      return nodeSet.nodes[0].nodeName.toLowerCase();  // TODO: no toLowerCase for xml\n    },\n    'namespace-uri': function(nodeSet) {\n      // TODO\n      throw new Error('not implemented yet');\n    },\n    'name': function(nodeSet) {\n      if (null == nodeSet)\n        return fn.name(this);\n      if (null == nodeSet.nodes) {\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'argument to name() must be a node-set. got ' + nodeSet);\n      }\n      return nodeSet.nodes[0].nodeName.toLowerCase();  // TODO: no toLowerCase for xml\n    },\n    'concat': function concat(x) {\n      var l = [];\n      for (var i = 0; i < arguments.length; ++i) {\n        l.push(fn.string(arguments[i]));\n      }\n      return l.join('');\n    },\n    'starts-with': function startsWith(a, b) {\n      var as = fn.string(a), bs = fn.string(b);\n      return as.substr(0, bs.length) === bs;\n    },\n    'contains': function contains(a, b) {\n      var as = fn.string(a), bs = fn.string(b);\n      var i = as.indexOf(bs);\n      if (-1 === i) return false;\n      return true;\n    },\n    'substring-before': function substringBefore(a, b) {\n      var as = fn.string(a), bs = fn.string(b);\n      var i = as.indexOf(bs);\n      if (-1 === i) return '';\n      return as.substr(0, i);\n    },\n    'substring-after': function substringBefore(a, b) {\n      var as = fn.string(a), bs = fn.string(b);\n      var i = as.indexOf(bs);\n      if (-1 === i) return '';\n      return as.substr(i + bs.length);\n    },\n    'substring': function substring(string, start, optEnd) {\n      if (null == string || null == start) {\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Must be at least 2 arguments to string()');\n      }\n      var sString = fn.string(string),\n          iStart = fn.round(start),\n          iEnd = optEnd == null ? null : fn.round(optEnd);\n      // Note that xpath string positions user 1-based index\n      if (iEnd == null)\n        return sString.substr(iStart - 1);\n      else\n        return sString.substr(iStart - 1, iEnd);\n    },\n    'string-length': function stringLength(optString) {\n      return fn.string.call(this, optString).length;\n    },\n    'normalize-space': function normalizeSpace(optString) {\n      var s = fn.string.call(this, optString);\n      return s.replace(/[ \\t\\r\\n]+/g, ' ').replace(/^ | $/g, '');\n    },\n    'translate': function translate(string, from, to) {\n      var sString = fn.string.call(this, string),\n          sFrom = fn.string(from),\n          sTo = fn.string(to);\n      var eachCharRe = [];\n      var map = {};\n      for (var i = 0; i < sFrom.length; ++i) {\n        var c = sFrom.charAt(i);\n        map[c] = sTo.charAt(i);  // returns '' if beyond length of sTo.\n        // copied from goog.string.regExpEscape in the Closure library.\n        eachCharRe.push(\n          c.replace(/([-()\\[\\]{}+?*.$\\^|,:#<!\\\\])/g, '\\\\$1').\n            replace(/\\x08/g, '\\\\x08'));\n      }\n      var re = new RegExp(eachCharRe.join('|'), 'g');\n      return sString.replace(re, function(c) {return map[c];});\n    },\n    /// Boolean functions\n    'not': function not(x) {\n      var bx = fn['boolean'](x);\n      return !bx;\n    },\n    'true': function trueVal() { return true; },\n    'false': function falseVal() { return false; },\n    // TODO\n    'lang': function lang(string) { throw new Error('Not implemented');},\n    'sum': function sum(optNodeSet) {\n      if (null == optNodeSet) return fn.sum(this);\n      // for node-sets, map id over each node value.\n      var sum = 0;\n      for (var i = 0; i < optNodeSet.nodes.length; ++i) {\n        var node = optNodeSet.nodes[i];\n        var x = fn.number({nodes:[node]});\n        sum += x;\n      }\n      return sum;\n    },\n    'floor': function floor(number) {\n      return Math.floor(fn.number(number));\n    },\n    'ceiling': function ceiling(number) {\n      return Math.ceil(fn.number(number));\n    },\n    'round': function round(number) {\n      return Math.round(fn.number(number));\n    }\n  };\n  /***************************************************************************\n   *                         Evaluation: operators                           *\n   ***************************************************************************/\n  var more = {\n    UnaryMinus: function(x) { return -fn.number(x); },\n    '+': function(x, y) { return fn.number(x) + fn.number(y); },\n    '-': function(x, y) { return fn.number(x) - fn.number(y); },\n    '*': function(x, y) { return fn.number(x) * fn.number(y); },\n    'div': function(x, y) { return fn.number(x) / fn.number(y); },\n    'mod': function(x, y) { return fn.number(x) % fn.number(y); },\n    '<': function(x, y) {\n      return comparisonHelper(function(x, y) { return fn.number(x) < fn.number(y);}, x, y, true);\n    },\n    '<=': function(x, y) {\n      return comparisonHelper(function(x, y) { return fn.number(x) <= fn.number(y);}, x, y, true);\n    },\n    '>':  function(x, y) {\n      return comparisonHelper(function(x, y) { return fn.number(x) > fn.number(y);}, x, y, true);\n    },\n    '>=': function(x, y) {\n      return comparisonHelper(function(x, y) { return fn.number(x) >= fn.number(y);}, x, y, true);\n    },\n    'and': function(x, y) { return fn['boolean'](x) && fn['boolean'](y); },\n    'or': function(x, y) { return fn['boolean'](x) || fn['boolean'](y); },\n    '|': function(x, y) { return {nodes: mergeNodeLists(x.nodes, y.nodes)}; },\n    '=': function(x, y) {\n      // optimization for two node-sets case: avoid n^2 comparisons.\n      if ('object' === typeof x && 'object' === typeof y) {\n        var aMap = {};\n        for (var i = 0; i < x.nodes.length; ++i) {\n          var s = fn.string({nodes:[x.nodes[i]]});\n          aMap[s] = true;\n        }\n        for (var i = 0; i < y.nodes.length; ++i) {\n          var s = fn.string({nodes:[y.nodes[i]]});\n          if (aMap[s]) return true;\n        }\n        return false;\n      } else {\n        return comparisonHelper(function(x, y) {return x === y;}, x, y);\n      }\n    },\n    '!=': function(x, y) {\n      // optimization for two node-sets case: avoid n^2 comparisons.\n      if ('object' === typeof x && 'object' === typeof y) {\n        if (0 === x.nodes.length || 0 === y.nodes.length) return false;\n        var aMap = {};\n        for (var i = 0; i < x.nodes.length; ++i) {\n          var s = fn.string({nodes:[x.nodes[i]]});\n          aMap[s] = true;\n        }\n        for (var i = 0; i < y.nodes.length; ++i) {\n          var s = fn.string({nodes:[y.nodes[i]]});\n          if (!aMap[s]) return true;\n        }\n        return false;\n      } else {\n        return comparisonHelper(function(x, y) {return x !== y;}, x, y);\n      }\n    }\n  };\n  var nodeTypes = xpath.nodeTypes = {\n    'node': 0,\n    'attribute': 2,\n    'comment': 8, // this.doc.COMMENT_NODE,\n    'text': 3, // this.doc.TEXT_NODE,\n    'processing-instruction': 7, // this.doc.PROCESSING_INSTRUCTION_NODE,\n    'element': 1  //this.doc.ELEMENT_NODE\n  };\n  /** For debugging and unit tests: returnjs a stringified version of the\n   * argument. */\n  var stringifyObject = xpath.stringifyObject = function stringifyObject(ctx) {\n    var seenKey = 'seen' + Math.floor(Math.random()*1000000000);\n    return JSON.stringify(helper(ctx));\n\n    function helper(ctx) {\n      if (Array.isArray(ctx)) {\n        return ctx.map(function(x) {return helper(x);});\n      }\n      if ('object' !== typeof ctx) return ctx;\n      if (null == ctx) return ctx;\n    //  if (ctx.toString) return ctx.toString();\n      if (null != ctx.outerHTML) return ctx.outerHTML;\n      if (null != ctx.nodeValue) return ctx.nodeName + '=' + ctx.nodeValue;\n      if (ctx[seenKey]) return '[circular]';\n      ctx[seenKey] = true;\n      var nicer = {};\n      for (var key in ctx) {\n        if (seenKey === key)\n          continue;\n        try {\n          nicer[key] = helper(ctx[key]);\n        } catch (e) {\n          nicer[key] = '[exception: ' + e.message + ']';\n        }\n      }\n      delete ctx[seenKey];\n      return nicer;\n    }\n  }\n  var Evaluator = xpath.Evaluator = function Evaluator(doc) {\n    this.doc = doc;\n  }\n  Evaluator.prototype = {\n    val: function val(ast, ctx) {\n      console.assert(ctx.nodes);\n\n      if ('number' === typeof ast || 'string' === typeof ast) return ast;\n      if (more[ast[0]]) {\n        var evaluatedParams = [];\n        for (var i = 1; i < ast.length; ++i) {\n          evaluatedParams.push(this.val(ast[i], ctx));\n        }\n        var r = more[ast[0]].apply(ctx, evaluatedParams);\n        return r;\n      }\n      switch (ast[0]) {\n        case 'Root': return {nodes: [this.doc]};\n        case 'FunctionCall':\n          var functionName = ast[1], functionParams = ast[2];\n          if (null == fn[functionName])\n            throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                     'Unknown function: ' + functionName);\n          var evaluatedParams = [];\n          for (var i = 0; i < functionParams.length; ++i) {\n            evaluatedParams.push(this.val(functionParams[i], ctx));\n          }\n          var r = fn[functionName].apply(ctx, evaluatedParams);\n          return r;\n        case 'Predicate':\n          var lhs = this.val(ast[1], ctx);\n          var ret = {nodes: []};\n          var contexts = eachContext(lhs);\n          for (var i = 0; i < contexts.length; ++i) {\n            var singleNodeSet = contexts[i];\n            var rhs = this.val(ast[2], singleNodeSet);\n            var success;\n            if ('number' === typeof rhs) {\n              success = rhs === singleNodeSet.pos[0][0];\n            } else {\n              success = fn['boolean'](rhs);\n            }\n            if (success) {\n              var node = singleNodeSet.nodes[0];\n              ret.nodes.push(node);\n              // skip over all the rest of the same node.\n              while (i+1 < contexts.length && node === contexts[i+1].nodes[0]) {\n                i++;\n              }\n            }\n          }\n          return ret;\n        case 'PathExpr':\n          // turn the path into an expressoin; i.e., remove the position\n          // information of the last axis.\n          var x = this.val(ast[1], ctx);\n          // Make the nodeset a forward-direction-only one.\n          if (x.finalize) {  // it is a NodeMultiSet\n            for (var i = 0; i < x.nodes.length; ++i) {\n              console.assert(null != x.nodes[i].nodeType);\n            }\n            return {nodes: x.nodes};\n          } else {\n            return x;\n          }\n        case '/':\n          // TODO: don't generate '/' nodes, just Axis nodes.\n          var lhs = this.val(ast[1], ctx);\n          console.assert(null != lhs);\n          var r = this.val(ast[2], lhs);\n          console.assert(null != r);\n          return r;\n        case 'Axis':\n          // All the axis tests from Step. We only get AxisSpecifier NodeTest,\n          // not the predicate (which is applied later)\n          var axis = ast[1],\n              nodeType = ast[2],\n              nodeTypeNum = nodeTypes[nodeType],\n              shouldLowerCase = true,  // TODO: give option\n              nodeName = ast[3] && shouldLowerCase ? ast[3].toLowerCase() : ast[3];\n          nodeName = nodeName === '*' ? null : nodeName;\n          if ('object' !== typeof ctx) return {nodes:[], pos:[]};\n          var nodeList = ctx.nodes.slice();  // TODO: is copy needed?\n          var r = axes[axis](nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase);\n          return r;\n      }\n    }\n  };\n  var evaluate = xpath.evaluate = function evaluate(expr, doc, context) {\n    //var astFactory = new AstEvaluatorFactory(doc, context);\n    var stream = new Stream(expr);\n    var ast = parse(stream, astFactory);\n    var val = new Evaluator(doc).val(ast, {nodes: [context]});\n    return val;\n  }\n\n  /***************************************************************************\n   *                           DOM interface                                 *\n   ***************************************************************************/\n  var XPathException = xpath.XPathException = function XPathException(code, message) {\n    var e = new Error(message);\n    e.name = 'XPathException';\n    e.code = code;\n    return e;\n  }\n  XPathException.INVALID_EXPRESSION_ERR = 51;\n  XPathException.TYPE_ERR = 52;\n\n\n  var XPathEvaluator = xpath.XPathEvaluator = function XPathEvaluator() {}\n  XPathEvaluator.prototype = {\n    createExpression: function(expression, resolver) {\n      return new XPathExpression(expression, resolver);\n    },\n    createNSResolver: function(nodeResolver) {\n      // TODO\n    },\n    evaluate: function evaluate(expression, contextNode, resolver, type, result) {\n      var expr = new XPathExpression(expression, resolver);\n      return expr.evaluate(contextNode, type, result);\n    }\n  };\n\n\n  var XPathExpression = xpath.XPathExpression = function XPathExpression(expression, resolver, optDoc) {\n    var stream = new Stream(expression);\n    this._ast = parse(stream, astFactory);\n    this._doc = optDoc;\n  }\n  XPathExpression.prototype = {\n    evaluate: function evaluate(contextNode, type, result) {\n      if (null == contextNode.nodeType)\n        throw new Error('bad argument (expected context node): ' + contextNode);\n      var doc = contextNode.ownerDocument || contextNode;\n      if (null != this._doc && this._doc !== doc) {\n        throw new core.DOMException(\n            core.WRONG_DOCUMENT_ERR,\n            'The document must be the same as the context node\\'s document.');\n      }\n      var evaluator = new Evaluator(doc);\n      var value = evaluator.val(this._ast, {nodes: [contextNode]});\n      if (XPathResult.NUMBER_TYPE === type)\n        value = fn.number(value);\n      else if (XPathResult.STRING_TYPE === type)\n        value = fn.string(value);\n      else if (XPathResult.BOOLEAN_TYPE === type)\n        value = fn['boolean'](value);\n      else if (XPathResult.ANY_TYPE !== type &&\n               XPathResult.UNORDERED_NODE_ITERATOR_TYPE !== type &&\n               XPathResult.ORDERED_NODE_ITERATOR_TYPE !== type &&\n               XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE !== type &&\n               XPathResult.ORDERED_NODE_SNAPSHOT_TYPE !== type &&\n               XPathResult.ANY_UNORDERED_NODE_TYPE !== type &&\n               XPathResult.FIRST_ORDERED_NODE_TYPE !== type)\n        throw new core.DOMException(\n            core.NOT_SUPPORTED_ERR,\n            'You must provide an XPath result type (0=any).');\n      else if (XPathResult.ANY_TYPE !== type &&\n               'object' !== typeof value)\n        throw new XPathException(\n            XPathException.TYPE_ERR,\n            'Value should be a node-set: ' + value);\n      return new XPathResult(doc, value, type);\n    }\n  }\n\n  var XPathResult = xpath.XPathResult = function XPathResult(doc, value, resultType) {\n    this._value = value;\n    this._resultType = resultType;\n    this._i = 0;\n    this._invalidated = false;\n    if (this.resultType === XPathResult.UNORDERED_NODE_ITERATOR_TYPE ||\n        this.resultType === XPathResult.ORDERED_NODE_ITERATOR_TYPE) {\n      doc.addEventListener('DOMSubtreeModified', invalidate, true);\n      var self = this;\n      function invalidate() {\n        self._invalidated = true;\n        doc.removeEventListener('DOMSubtreeModified', invalidate, true);\n      }\n    }\n  }\n  XPathResult.ANY_TYPE = 0;\n  XPathResult.NUMBER_TYPE = 1;\n  XPathResult.STRING_TYPE = 2;\n  XPathResult.BOOLEAN_TYPE = 3;\n  XPathResult.UNORDERED_NODE_ITERATOR_TYPE = 4;\n  XPathResult.ORDERED_NODE_ITERATOR_TYPE = 5;\n  XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE = 6;\n  XPathResult.ORDERED_NODE_SNAPSHOT_TYPE = 7;\n  XPathResult.ANY_UNORDERED_NODE_TYPE = 8;\n  XPathResult.FIRST_ORDERED_NODE_TYPE = 9;\n  var proto = {\n    // XPathResultType\n    get resultType() {\n      if (this._resultType) return this._resultType;\n      switch (typeof this._value) {\n        case 'number': return XPathResult.NUMBER_TYPE;\n        case 'string': return XPathResult.STRING_TYPE;\n        case 'boolean': return XPathResult.BOOLEAN_TYPE;\n        default: return XPathResult.UNORDERED_NODE_ITERATOR_TYPE;\n      }\n    },\n    get numberValue() {\n      if (XPathResult.NUMBER_TYPE !== this.resultType)\n        throw new XPathException(XPathException.TYPE_ERR,\n                                 'You should have asked for a NUMBER_TYPE.');\n      return this._value;\n    },\n    get stringValue() {\n      if (XPathResult.STRING_TYPE !== this.resultType)\n        throw new XPathException(XPathException.TYPE_ERR,\n                                 'You should have asked for a STRING_TYPE.');\n      return this._value;\n    },\n    get booleanValue() {\n      if (XPathResult.BOOLEAN_TYPE !== this.resultType)\n        throw new XPathException(XPathException.TYPE_ERR,\n                                 'You should have asked for a BOOLEAN_TYPE.');\n      return this._value;\n    },\n    get singleNodeValue() {\n      if (XPathResult.ANY_UNORDERED_NODE_TYPE !== this.resultType &&\n          XPathResult.FIRST_ORDERED_NODE_TYPE !== this.resultType)\n        throw new XPathException(\n            XPathException.TYPE_ERR,\n            'You should have asked for a FIRST_ORDERED_NODE_TYPE.');\n      return this._value.nodes[0] || null;\n    },\n    get invalidIteratorState() {\n      if (XPathResult.UNORDERED_NODE_ITERATOR_TYPE !== this.resultType &&\n          XPathResult.ORDERED_NODE_ITERATOR_TYPE !== this.resultType)\n        return false;\n      return !!this._invalidated;\n    },\n    get snapshotLength() {\n      if (XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE !== this.resultType &&\n          XPathResult.ORDERED_NODE_SNAPSHOT_TYPE !== this.resultType)\n        throw new XPathException(\n            XPathException.TYPE_ERR,\n            'You should have asked for a ORDERED_NODE_SNAPSHOT_TYPE.');\n      return this._value.nodes.length;\n    },\n    iterateNext: function iterateNext() {\n      if (XPathResult.UNORDERED_NODE_ITERATOR_TYPE !== this.resultType &&\n          XPathResult.ORDERED_NODE_ITERATOR_TYPE !== this.resultType)\n        throw new XPathException(\n            XPathException.TYPE_ERR,\n            'You should have asked for a ORDERED_NODE_ITERATOR_TYPE.');\n      if (this.invalidIteratorState)\n        throw new core.DOMException(\n            core.INVALID_STATE_ERR,\n            'The document has been mutated since the result was returned');\n      return this._value.nodes[this._i++] || null;\n    },\n    snapshotItem: function snapshotItem(index) {\n      if (XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE !== this.resultType &&\n          XPathResult.ORDERED_NODE_SNAPSHOT_TYPE !== this.resultType)\n        throw new XPathException(\n            XPathException.TYPE_ERR,\n            'You should have asked for a ORDERED_NODE_SNAPSHOT_TYPE.');\n      return this._value.nodes[index] || null;\n    }\n  };\n  // so you can access ANY_TYPE etc. from the instances:\n  XPathResult.prototype = Object.create(XPathResult,\n      Object.keys(proto).reduce(function (descriptors, name) {\n        descriptors[name] = Object.getOwnPropertyDescriptor(proto, name);\n        return descriptors;\n      }, {\n        constructor: {\n          value: XPathResult,\n          writable: true,\n          configurable: true\n        }\n      }));\n\n  core.XPathException = XPathException;\n  core.XPathExpression = XPathExpression;\n  core.XPathResult = XPathResult;\n  core.XPathEvaluator = XPathEvaluator;\n\n  core.Document.prototype.createExpression =\n    XPathEvaluator.prototype.createExpression;\n\n  core.Document.prototype.createNSResolver =\n      XPathEvaluator.prototype.createNSResolver;\n\n  core.Document.prototype.evaluate = XPathEvaluator.prototype.evaluate;\n\n})();\n"]},"metadata":{},"sourceType":"script"}